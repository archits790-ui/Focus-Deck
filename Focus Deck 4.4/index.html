<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Focus-Deck</title>
  <!-- Image link is kept as-is from your file -->
  <link rel="icon" type="image/png" href="./unnamed-removebg-preview.png">

  <!-- Google Fonts for Sticky Notes -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Kalam:wght@400;700&display=swap" rel="stylesheet">

  <style>
    /* ===== Root Variables and Theming ===== */
    :root {
      --bg: #0f1115;
      --panel: #151926;
      --muted: #8892a6;
      --text: #e5e7ef;
      --accent: #6ea8fe;
      --accent-2: #8bd5ff;
      --ok: #59d18c;
      --warn: #ffcc66;
      --danger: #ff6b6b;
      --shadow: 0 6px 20px rgba(0, 0, 0, .25);
      --radius: 14px;
      --gap: 16px;
      /* Increased gap for new layout */
      --ring: 0 0 0 3px var(--accent) inset;
    }

    .light {
      --bg: #f6f7fb;
      --panel: #fff;
      --muted: #5c6473;
      --text: #1b2130;
      --accent: #3d7eff;
      --accent-2: #1fb6ff;
      --ok: #1dbb72;
      --warn: #e0a800;
      --danger: #e55353;
      --shadow: 0 6px 18px rgba(25, 25, 35, .06)
    }

    /* ===== Global Styles ===== */
    * {
      box-sizing: border-box
    }

    html {
      height: 100%;
    }

    body {
      min-height: 100vh;
    }

    body.modal-open {
      overflow: hidden;
    }

    body {
      margin: 0;
      padding-bottom: 0;
      /* REMOVED padding for settings bar */
      background: linear-gradient(180deg, var(--bg), #0b0d12);
      color: var(--text);
      font: 14px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
    }

    .light body {
      background: var(--bg);
    }

    .app {
      display: grid;
      grid-template-rows: auto 1fr;
      /* Header, then main content */
      overflow-x: hidden;
      /* Prevent horizontal scroll from layout shifts */
    }

    /* ===== Header Styles (Unchanged) ===== */
    header {
      position: sticky;
      top: 0;
      z-index: 20;
      background: rgba(21, 25, 38, .76);
      backdrop-filter: saturate(140%) blur(8px);
      border-bottom: 1px solid rgba(255, 255, 255, .04)
    }

    .light header {
      background: rgba(255, 255, 255, .76);
      border-bottom: 1px solid rgba(0, 0, 0, .06);
    }

    .header-wrap {
      max-width: 100%;
      margin: auto;
      padding: 10px 16px;
      display: flex;
      justify-content: space-between;
      gap: 12px;
      align-items: center
    }

    .brand {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-left: 60px;
    }

    #streakCounter {
      font-weight: 600;
      font-size: 16px;
      cursor: help;
    }

    .greet {
      font-weight: 600
    }

    .clock {
      font-variant-numeric: tabular-nums;
      color: var(--muted)
    }

    .controls {
      display: flex;
      gap: 8px;
      align-items: center
    }

    /* ===== Form & Button Styles (Unchanged) ===== */
    select,
    input,
    button,
    textarea,
    .tab {
      background: var(--panel);
      border: 1px solid rgba(255, 255, 255, .04);
      border-radius: 10px;
      color: var(--text);
      padding: 8px 10px;
      box-shadow: var(--shadow);
      font-family: inherit;
    }

    .light select,
    .light input,
    .light button,
    .light textarea,
    .light .tab {
      border-color: rgba(0, 0, 0, 0.08);
    }

    .tab.active {
      background: var(--accent);
      color: #fff;
      border-color: transparent;
    }

    .light .tab.active {
      color: #fff;
    }

    .tabs {
      display: flex;
      gap: 8px;
    }

    input[type=text] {
      width: 260px
    }

    button {
      cursor: pointer;
      transition: transform .12s ease, background-color .12s ease, box-shadow .12s ease, color .12s ease, border-color .12s ease;
    }

    button:hover {
      transform: translateY(-2px);
    }

    button,
    .tab {
      background: var(--panel);
      border: 1px solid rgba(255, 255, 255, .08);
    }

    .light button,
    .light .tab {
      border-color: rgba(0, 0, 0, 0.1);
    }

    button:hover,
    .tab:hover {
      background-color: #ffffff;
      color: #1b2130 !important;
      /* Important to override custom text colors on hover */
      border-color: #ffffff;
    }

    .light button:hover,
    .light .tab:hover {
      background-color: #1b2130;
      color: #ffffff !important;
      /* Important to override custom text colors on hover */
      border-color: #1b2130;
    }

    .accent {
      background: linear-gradient(180deg, var(--accent), var(--accent-2));
      color: #fff;
      border: none
    }

    .accent:hover {
      filter: brightness(1.1);
    }


    /* ===== NEW: Main Content Layout (30/70 Split) ===== */
    .main-content {
      padding: var(--gap);
      /* "a bit of margin" */
      display: flex;
      gap: var(--gap);
      align-items: stretch;
      width: 100%;
      margin: 0 0 0 0;
      /* REMOVED margin-bottom for settings bar */
    }

    .left-column {
      flex: 0 0 30%;
      min-width: 320px;
      /* Ensure it doesn't get too crushed */
      display: flex;
      flex-direction: column;
      gap: var(--gap);
    }

    .right-column {
      flex: 1 1 70%;
      min-width: 0;
      /* Allow flex-shrink */
      display: flex;
      flex-direction: column;
      gap: var(--gap);
    }

    /* ===== NEW: Right Column Tab Navigation ===== */
    .right-nav-tabs {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      /* Allow tabs to wrap */
      padding: 10px 14px;
      /* Match card header padding */
      background: var(--panel);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      border: 1px solid rgba(255, 255, 255, .04);
    }

    .light .right-nav-tabs {
      border-color: transparent;
    }

    /* Use existing tab styles but modify for this container */
    .right-nav-tabs .tab {
      box-shadow: none;
      border: none;
      background: transparent;
    }

    .right-nav-tabs .tab.active {
      box-shadow: var(--shadow);
    }

    .right-nav-tabs .tab {
      background-color: #007bff;
      color: white;
      border-radius: 999px;
      transition: transform 0.2s, background-color 0.2s, color 0.2s;
    }

    .right-nav-tabs .tab:hover,
    .right-nav-tabs .tab:active {
      background-color: white;
      color: black;
      transform: scale(0.95);
    }

    /* ===== CHANGE 1: Fix light mode nav hover ===== */
    /* This new rule overrides the one above ONLY in light mode */
    .light .right-nav-tabs .tab:hover,
    .light .right-nav-tabs .tab:active {
      background-color: var(--text);
      /* This is black/dark in light mode */
      color: var(--panel);
      /* This is white in light mode */
    }

    /* ============================================ */

    /* ===== CHANGE 2: Make right column content area stretch ===== */
    .right-content-area {
      flex-grow: 1;
      /* Make this area fill the remaining vertical space in .right-column */
      display: flex;
      /* Use flex to manage the active card inside it */
      min-height: 600px;
      /* Prevents flexbox overflow issues */
    }

    /* ========================================================== */

    .right-content-area>.card {
      display: none;
      /* Hide all cards by default */
    }

    .right-content-area>.card.active {
      display: flex;
      /* Show the active one */
      width: 100%;
      /* Ensure it fills the right column */
      grid-column: span 12;
      /* Override any old grid styles */
      flex-grow: 1;
      /* ===== CHANGE 2: Make the active card fill the .right-content-area ===== */
    }

    /* ===== Card Layout (Modified) ===== */
    /* .grid styles are removed, now we just style .card */
    .card {
      /* grid-column: span 4; */
      /* This is no longer needed */
      width: 100%;
      /* Cards fill their parent column */
      background: var(--panel);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      border: 1px solid rgba(255, 255, 255, .04);
      transition: all 0.3s ease-in-out;
    }

    .light .card {
      border-color: transparent;
    }

    /* Expanded card styles (Unchanged) */
    .card.expanded {
      position: fixed;
      top: 16px;
      left: 16px;
      right: 16px;
      bottom: 16px;
      width: calc(100% - 32px);
      height: calc(100% - 32px);
      z-index: 100;
      grid-column: 1 / -1 !important;
      /* Ensure it overrides any leftover grid styles */
    }

    .card.expanded .card-body {
      flex-grow: 1;
      overflow-y: auto;
    }

    .card.expanded .timetable {
      flex-grow: 1;
      max-height: none;
      overflow: auto;
    }

    /* Card Header/Body (Unchanged) */
    .card-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 14px;
      border-bottom: 1px solid rgba(255, 255, 255, .04);
      flex-shrink: 0;
    }

    .light .card-header {
      border-bottom: 1px solid rgba(0, 0, 0, .06);
    }

    .card-title {
      font-weight: 600
    }

    .card-body {
      padding: 14px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      flex-grow: 1;
      overflow: auto;
      /* This is key for Change 2: card body will scroll if content is too tall */
    }

    /* Specific card constraints (Unchanged) */
    /* These max-heights will apply when the card is NOT stretched */
    #todoCard .card-body,
    #syllabusCard .card-body {
      max-height: 600px;
    }

    .card.expanded#todoCard .card-body,
    .card.expanded#syllabusCard .card-body {
      max-height: none;
    }


    /* ===== NEW: Streak Info Card ===== */
    .streak-info-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      text-align: center;
    }

    .streak-info-item {
      background: rgba(255, 255, 255, .015);
      border-radius: 10px;
      padding: 12px 8px;
      border: 1px solid rgba(255, 255, 255, .03);
    }

    .light .streak-info-item {
      background: rgba(0, 0, 0, .015);
      border-color: rgba(0, 0, 0, .03);
    }

    .streak-info-item .label {
      font-size: 12px;
      color: var(--muted);
    }

    .streak-info-item .value {
      font-size: 20px;
      font-weight: 600;
      color: var(--accent);
    }

    /* Expanded view for Streak Card */
    #streakInfoCard.expanded .card-body {
      justify-content: center;
    }

    #streakInfoCard.expanded .streak-info-item .label {
      font-size: 16px;
    }

    #streakInfoCard.expanded .streak-info-item .value {
      font-size: 48px;
    }

    #streakInfoCard .expanded-only {
      display: none;
    }

    #streakInfoCard.expanded .expanded-only {
      display: block;
      grid-column: span 2;
      /* Span full width */
    }


    /* ===== NEW: Badges Card ===== */
    #badgesCard .card-body {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
      gap: 16px;
      justify-items: center;
    }

    .flip-card {
      background-color: transparent;
      width: 100px;
      height: 100px;
      perspective: 1000px;
      /* 3D effect */
      cursor: pointer;
    }

    .flip-card-inner {
      position: relative;
      width: 100%;
      height: 100%;
      text-align: center;
      transition: transform 0.6s;
      transform-style: preserve-3d;
      border-radius: var(--radius);
    }

    /* This class is added by JS on click */
    .flip-card.flipped .flip-card-inner {
      transform: rotateY(180deg);
    }

    .flip-card-front,
    .flip-card-back {
      position: absolute;
      width: 100%;
      height: 100%;
      -webkit-backface-visibility: hidden;
      /* Safari */
      backface-visibility: hidden;
      border-radius: var(--radius);
      background: var(--panel);
      box-shadow: var(--shadow);
      border: 1px solid rgba(255, 255, 255, .04);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      padding: 8px;
    }

    .light .flip-card-front,
    .light .flip-card-back {
      border-color: rgba(0, 0, 0, 0.08);
      /* Light mode shadow */
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    }

    .flip-card-back {
      transform: rotateY(180deg);
      font-size: 11px;
      line-height: 1.3;
    }

    .badge-icon {
      font-size: 40px;
    }

    .badge-title {
      font-size: 12px;
      font-weight: 600;
      margin-top: 5px;
    }

    .badge-locked .badge-icon {
      filter: blur(5px) grayscale(100%);
      opacity: 0.5;
    }

    .badge-locked .badge-title {
      color: var(--muted);
    }

    /* ===== Component Styles (Unchanged) ===== */
    .row {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap
    }

    .column {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .list {
      display: flex;
      flex-direction: column;
      gap: 8px
    }

    .item {
      display: grid;
      grid-template-columns: auto 1fr auto;
      gap: 8px;
      align-items: center;
      background: rgba(255, 255, 255, .015);
      border-radius: 10px;
      padding: 8px;
      border: 1px solid rgba(255, 255, 255, .03)
    }

    .light .item {
      background: rgba(0, 0, 0, .015);
      border-color: rgba(0, 0, 0, .03);
    }

    .task-item,
    .subj {
      background: rgba(255, 255, 255, .015);
      border-radius: 10px;
      /* padding: 8px; */
      border: 1px solid rgba(255, 255, 255, .03);
    }

    .light .task-item,
    .light .subj {
      background: rgba(0, 0, 0, .015);
      border-color: rgba(0, 0, 0, .03);
    }

    .task-item.recurring-completed .text {
      text-decoration: line-through;
      color: var(--muted);
    }

    .item.dragging,
    .task-item.dragging,
    .subj.dragging {
      opacity: .6;
      border-style: dashed
    }

    .drag-handle {
      cursor: grab;
      color: var(--muted);
      padding: 0 8px;
      align-self: stretch;
      display: flex;
      align-items: center;
    }

    .drag-handle:active {
      cursor: grabbing;
    }


    .progress {
      height: 8px;
      background: rgba(255, 255, 255, .06);
      border-radius: 999px;
      overflow: hidden;
      margin-top: 4px;
    }

    .light .progress {
      background: rgba(0, 0, 0, .06);
    }

    .progress>span {
      display: block;
      height: 100%;
      background: linear-gradient(90deg, var(--accent), var(--ok));
      transition: width 0.3s ease-in-out;
    }

    .canvas-wrap {
      width: 100%;
      min-height: 220px;
      flex-grow: 1;
    }

    .canvas-wrap canvas {
      width: 100% !important;
      height: 100% !important;
    }

    .timetable {
      overflow: auto;
      max-height: 300px;
      /* This max-height applies in the *default* state, but will be overridden by flex-grow when the card stretches */
    }

    .table {
      min-width: 680px;
      border-collapse: separate;
      border-spacing: 0;
      width: 100%;
      table-layout: fixed;
    }

    .table th,
    .table td {
      border: 1px solid rgba(255, 255, 255, .06);
      padding: 8px;
      min-width: 100px;
      text-align: left;
      vertical-align: top;
    }

    .light .table th,
    .light .table td {
      border-color: rgba(0, 0, 0, 0.08);
    }

    .table td .cell {
      display: flex;
      align-items: center;
    }

    .activity-pill {
      padding: 4px 8px;
      border-radius: 8px;
      width: 100%;
      box-sizing: border-box;
      display: block;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .table th {
      position: sticky;
      top: 0;
      background: rgba(21, 25, 38, .9);
    }

    .light .table th {
      background: rgba(255, 255, 255, .9);
    }

    .settings-group {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    .color-dot {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      border: 1px solid rgba(255, 255, 255, .12);
      cursor: pointer;
      transition: transform .12s ease
    }

    .color-dot:hover {
      transform: translateY(-3px) scale(1.06);
      box-shadow: 0 6px 18px rgba(0, 0, 0, .12)
    }

    .footer {
      max-width: 100%;
      /* Use full width */
      margin: 8px auto 24px;
      padding: 0 16px;
      color: var(--muted);
      font-size: 12px;
      text-align: center;
    }

    /* ===== Overlays (Modal, Context Menu) (Unchanged) ===== */
    .modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, .45);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 120;
    }

    .modal-card {
      background: var(--panel);
      border: 1px solid rgba(255, 255, 255, .12);
      border-radius: 12px;
      box-shadow: var(--shadow);
      min-width: 320px;
      max-width: 92vw;
      padding: 16px
    }

    .light .modal-card {
      border-color: rgba(0, 0, 0, 0.08);
    }

    .subj .topics,
    .task-item .subtask-list-container {
      display: block
    }

    .subj.collapsed .topics,
    .task-item.collapsed .subtask-list-container {
      display: none
    }

    .context-menu {
      position: fixed;
      background: var(--panel);
      border: 1px solid rgba(255, 255, 255, .06);
      border-radius: 8px;
      display: none;
      flex-direction: column;
      min-width: 160px;
      z-index: 130;
      padding: 6px;
      box-shadow: var(--shadow)
    }

    .context-menu button {
      background: transparent;
      border: none;
      color: var(--text);
      padding: 8px;
      text-align: left;
      cursor: pointer;
      border-radius: 6px
    }

    .context-menu button:hover {
      background-color: #ffffff;
      color: #1b2130 !important;
    }

    .light .context-menu button:hover {
      background-color: #1b2130;
      color: #ffffff !important;
    }


    #chartTooltip,
    #dateTooltip,
    #timetableTooltip {
      position: fixed;
      display: none;
      background: rgba(0, 0, 0, 0.85);
      color: white;
      padding: 8px 12px;
      border-radius: 8px;
      pointer-events: none;
      z-index: 110;
      font-size: 12px;
      white-space: pre-wrap;
      backdrop-filter: blur(4px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      max-width: 300px;
    }

    #dateTooltip,
    #timetableTooltip {
      pointer-events: auto;
    }

    #dateTooltip .tooltip-content,
    #timetableTooltip .tooltip-content {
      max-height: 250px;
      overflow-y: auto;
      padding-right: 8px;
    }

    #dateTooltip h4 {
      margin: 8px 0 4px;
      color: var(--accent);
    }

    #dateTooltip p {
      margin: 2px 0;
      white-space: normal;
    }

    .analytics-tabs .tab {
      padding: 6px 10px;
      font-size: 12px;
    }

    /* ===== Sticky Notes & Calendar Styles (Unchanged) ===== */
    #stickyNotesCard .card-body {
      position: relative;
      overflow: hidden;
    }

    #stickyNotesCard.expanded .card-header {
      display: none;
    }

    #stickyNotesCard.expanded .card-body {
      overflow: auto;
      cursor: grab;
      padding: 0;
      position: relative;
    }

    #stickyNotesCanvas {
      width: 100%;
      height: 100%;
      position: relative;
    }

    #stickyNotesCard.expanded #stickyNotesCanvas {
      width: 3000px;
      height: 2000px;
    }

    .sticky-note {
      position: absolute;
      width: 220px;
      height: 200px;
      background: var(--warn);
      color: #1b2130;
      border-radius: 4px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      padding: 10px;
      display: flex;
      flex-direction: column;
      cursor: move;
      transform: rotate(-2deg);
      transition: transform 0.1s ease-out, box-shadow 0.1s ease-out;
    }

    .sticky-note.dragging {
      transform: scale(1.05) rotate(0deg);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
      z-index: 110;
    }

    .sticky-note-text {
      flex-grow: 1;
      background: transparent;
      border: none;
      resize: none;
      font-family: 'Kalam', cursive, system-ui;
      font-size: 15px;
      padding-top: 5px;
      color: inherit;
    }

    .sticky-note-text:focus {
      outline: none;
      background: rgba(0, 0, 0, 0.05);
    }

    .sticky-note-files {
      font-size: 12px;
      max-height: 60px;
      overflow-y: auto;
      word-break: break-all;
    }

    .sticky-note-files .file-link {
      display: block;
      padding: 2px 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      color: #0b0d12;
      text-decoration: underline;
      cursor: pointer;
    }

    .sticky-note-files .file-link:hover {
      opacity: 0.7;
    }

    .delete-sticky-note {
      position: absolute;
      top: 2px;
      right: 2px;
      background: rgba(0, 0, 0, 0.2);
      color: white;
      border: none;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      line-height: 18px;
      text-align: center;
      cursor: pointer;
      opacity: 0.2;
      transition: opacity 0.2s;
    }

    .sticky-note:hover .delete-sticky-note {
      opacity: 1;
    }

    #addStickyNoteBtn {
      display: none;
      position: fixed;
      bottom: 50px;
      right: 40px;
      z-index: 105;
    }

    #stickyNotesCard.expanded #addStickyNoteBtn {
      display: block;
    }

    /* Calendar Styles */
    .calendar-container {
      display: flex;
      flex-direction: column;
      height: 100%;
    }

    .calendar-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0 8px;
    }

    #calendarMonthYear {
      font-weight: 600;
    }

    .calendar-body {
      flex-grow: 1;
      perspective: 1000px;
    }

    .calendar-grid {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      height: 100%;
      gap: 2px;
      transition: transform 0.6s;
      transform-style: preserve-3d;
    }

    .calendar-grid.flip-next {
      animation: flip-next 0.6s forwards;
    }

    .calendar-grid.flip-prev {
      animation: flip-prev 0.6s forwards;
    }

    @keyframes flip-next {
      from {
        transform: rotateY(0);
      }

      to {
        transform: rotateY(-180deg);
      }
    }

    @keyframes flip-prev {
      from {
        transform: rotateY(0);
      }

      to {
        transform: rotateY(180deg);
      }
    }

    .calendar-day {
      text-align: center;
      font-size: 12px;
      color: var(--muted);
      padding: 4px 0;
    }

    .date-cell {
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 8px;
      cursor: pointer;
      transition: background .2s;
      position: relative;
    }

    .date-cell:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .light .date-cell:hover {
      background: rgba(0, 0, 0, 0.1);
    }

    .date-cell.other-month {
      color: var(--muted);
      opacity: 0.5;
    }

    .date-cell.today {
      background-color: var(--accent);
      color: #fff;
      font-weight: bold;
    }

    .light .date-cell.today {
      color: #fff;
    }

    /* ===== NEW CALENDAR STYLES ===== */
    .date-cell.has-data::after {
      content: '‚Ä¢';
      position: absolute;
      bottom: 2px;
      /* adjust position */
      left: 50%;
      transform: translateX(-50%);
      width: auto;
      height: auto;
      border-radius: 0;
      background-color: transparent;
      /* Dot is now a character */
      color: var(--ok);
      font-size: 20px;
      /* Make dot big */
      line-height: 1;
    }

    .date-cell.has-reminder::after {
      content: '‚òÖ';
      /* \2605 */
      position: absolute;
      bottom: 6px;
      left: 50%;
      transform: translateX(-50%);
      width: auto;
      height: auto;
      border-radius: 0;
      background-color: transparent;
      color: var(--warn);
      font-size: 16px;
      line-height: 1;
    }

    /* ===== Settings Bar Styles (MODIFIED) ===== */
    .settings-bar {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      background: rgba(21, 25, 38, .85);
      backdrop-filter: saturate(140%) blur(8px);
      border-top: 1px solid rgba(255, 255, 255, .04);
      padding: 10px 16px;
      z-index: 50;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 24px;
      flex-wrap: wrap;

      /* NEW: Add transition for sliding */
      transform: translateY(100%);
      transition: transform 0.3s ease-in-out;
      visibility: hidden;
    }

    .settings-bar.visible {
      transform: translateY(0);
      visibility: visible;
    }


    .light .settings-bar {
      background: rgba(255, 255, 255, .85);
      border-top: 1px solid rgba(0, 0, 0, .06);
    }

    /* NEW: Style for About link in settings bar */
    .settings-about-link {
      text-decoration: none;
      color: var(--muted);
      font-size: 14px;
      padding: 8px 10px;
      /* Match button padding for alignment */
      transition: color 0.12s ease;
    }

    .settings-about-link:hover {
      color: var(--accent) !important;
      /* Blue on hover (accent color) */
    }


    /* ===== NEW: Corner Controls Styles ===== */
    .corner-controls {
      position: fixed;
      bottom: 16px;
      left: 16px;
      z-index: 51;
      /* Above settings bar but below modal */
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .corner-controls .ghost {
      /* Make icon button and link match */
      background: var(--panel);
      border: 1px solid rgba(255, 255, 255, .08);
      box-shadow: var(--shadow);
      padding: 8px 10px;
      text-decoration: none;
      font-size: 14px;
    }

    .light .corner-controls .ghost {
      border-color: rgba(0, 0, 0, 0.1);
    }

    .corner-controls .ghost:hover {
      background-color: #ffffff;
      color: #1b2130 !important;
      border-color: #ffffff;
    }

    .light .corner-controls .ghost:hover {
      background-color: #1b2130;
      color: #ffffff !important;
      border-color: #1b2130;
    }

    #toggleSettingsBtn {
      font-size: 18px;
      /* Make icon slightly larger */
      padding: 8px;
      line-height: 1;
    }

    #aboutLink {
      color: var(--text);
    }


    .color-picker-modal .color-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(30px, 1fr));
      gap: 10px;
      margin-bottom: 20px;
      max-height: 150px;
      overflow-y: auto;
      padding-right: 8px;
    }

    .color-picker-modal .color-grid .color-dot {
      width: 30px;
      height: 30px;
    }

    .color-picker-modal .advanced-options {
      max-height: 150px;
      overflow-y: auto;
      padding-right: 8px;
    }

    .color-picker-modal .advanced-options .item {
      grid-template-columns: 1fr auto;
    }

    /* ===== Timer Settings in Expanded View (Unchanged) ===== */
    .timer-settings {
      display: none;
      padding: 14px;
      border-top: 1px solid rgba(255, 255, 255, .04);
    }

    .light .timer-settings {
      border-top: 1px solid rgba(0, 0, 0, .06);
    }

    #timerCard.expanded .timer-settings {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    /* ===== Responsive Media Queries (MODIFIED) ===== */
    @media (max-width:1100px) {

      /* NEW: Stack columns on smaller screens */
      .main-content {
        flex-direction: column;
      }

      .left-column,
      .right-column {
        flex-basis: 100%;
        /* Full width when stacked */
        width: 100%;
        min-width: 0;
      }

      /* Original styles */
      .settings-bar {
        justify-content: space-around;
      }
    }

    @media (max-width:700px) {

      /* Original header styles */
      .header-wrap {
        /* This was flex, changing to grid to match original logic */
        display: grid;
        grid-template-columns: 1fr auto;
      }

      .header-wrap .controls:nth-of-type(2) {
        grid-area: 2 / 1 / 3 / 3;
        justify-content: center;
      }

      .brand {
        grid-area: 1 / 1 / 2 / 2;
      }

      .header-wrap .controls:first-of-type {
        grid-area: 1 / 2 / 2 / 3;
      }

      input[type=text] {
        width: 100%
      }

      /* Card span is no longer needed */
      /* .card { grid-column: span 12 } */

      /* Original settings bar styles */
      .settings-bar {
        flex-direction: column;
        padding-bottom: 15px;
        height: auto;
        gap: 12px;
      }

      .main-content {
        margin-bottom: 0;
        /* REMOVED margin-bottom */
      }
    }

    @media (max-width: 480px) {

      /* Original styles */
      .greet,
      .clock {
        display: none;
      }

      .settings-group {
        width: 100%;
        justify-content: center;
      }

      #openResetSettings {
        margin-left: 0 !important;
      }
    }

    /* ===== NEW: Reminder Modal Styles ===== */
    #reminderListModal .item .text {
      flex-grow: 1;
      word-break: break-word;
      padding-right: 8px;
    }
  </style>
</head>

<body>
  <!-- This image is from the original file, kept as requested -->
  <img src="unnamed-removebg-preview.png"
    style="position: fixed; top: 5px; left: 0px; width: 50px; height: 50px; z-index: 1000;">

  <div class="app" id="app">
    <!-- ===== HEADER (MODIFIED) ===== -->
    <header>
      <div class="header-wrap">
        <div class="brand">
          <div id="streakCounter" class="badge" title="Your current focus streak">0 <span class="fire-emoji">üî•</span></div>
          <div class="greet" id="greet">Good Day</div>
          <div class="clock" id="clock">--:--</div>
        </div>
        <div class="controls">
          <select id="workspaceSelect" title="Workspaces"></select>
          <button id="addWorkspace" class="ghost" title="Add workspace">Ôºã</button>
          <button id="delWorkspace" class="ghost" title="Delete workspace">üóë</button>
        </div>
        <div class="controls">
          <!-- NEW: Theme toggle button added here -->
          <button id="themeToggleBtn" class="ghost" title="Toggle Theme" style="font-size: 18px; padding: 8px; line-height: 1;">‚òÄÔ∏è</button>
          <input id="globalSearch" type="text" placeholder="Global search (tasks, topics)" />
        </div>
      </div>
    </header>

    <!-- ===== NEW 30/70 MAIN CONTENT LAYOUT ===== -->
    <main class="main-content">

      <!-- ===== LEFT 30% COLUMN ===== -->
      <div class="left-column">

        <!-- Focus Timer Card (Moved to Left) -->
        <section class="card" id="timerCard">
          <div class="card-header">
            <div class="card-title">Focus Timer</div>
            <div class="row">
              <select id="mode">
                <option value="focus">Focus</option>
                <option value="short">Short Break</option>
                <option value="long">Long Break</option>
              </select>
              <button class="icon-btn expand-btn" data-target="timerCard" title="Expand">‚Üó</button>
            </div>
          </div>
          <div class="card-body" style="align-items:center;text-align:center">
            <div id="display" style="font-size:48px">25:00</div>
            <div class="row">
              <button class="accent" id="start">Start</button>
              <button id="pause">Pause</button>
              <button id="reset">Reset</button>
            </div>
            <div class="badge" id="timerStatus">Idle</div>
            <div id="cycleDisplay" class="badge" style="margin-top: 8px;">Cycle 1 / 4</div>
          </div>
          <div class="timer-settings">
            <div class="settings-group">
              <span class="badge">Cycles until Long Break:</span>
              <input id="longBreakInterval" type="number" min="1" style="width:60px"
                title="Number of Focus sessions before a Long Break">
            </div>
            <button id="saveTimerSettings" class="accent">Save Settings</button>
          </div>
          <audio id="alarmSound" src="https://www.soundjay.com/buttons/sounds/button-1.mp3" preload="auto"></audio>
        </section>

        <!-- NEW: Streak Info Card -->
        <section class="card" id="streakInfoCard">
          <div class="card-header">
            <div class="card-title">Streak Info</div>
            <div class="row">
              <button class="icon-btn expand-btn" data-target="streakInfoCard" title="Expand">‚Üó</button>
            </div>
          </div>
          <div class="card-body">
            <div class="streak-info-grid">
              <div class="streak-info-item">
                <div class="label">Current Streak</div>
                <div class="value" id="currentStreakDisplay">0</div>
              </div>
              <div class="streak-info-item">
                <div class="label">Longest Streak</div>
                <div class="value" id="longestStreakDisplay">0</div>
              </div>
              <div class="streak-info-item expanded-only">
                <div class="label">Total Days Used</div>
                <div class="value" id="totalDaysDisplay">0</div>
              </div>
            </div>
          </div>
        </section>

        <!-- NEW: Badges Card -->
        <section class="card" id="badgesCard">
          <div class="card-header">
            <div class="card-title">Badges</div>
            <div class="row">
              <button class="icon-btn expand-btn" data-target="badgesCard" title="Expand">‚Üó</button>
            </div>
          </div>
          <div class="card-body">
            <!-- Badges will be dynamically rendered here by script.js -->
          </div>
        </section>

      </div> <!-- End .left-column -->

      <!-- ===== RIGHT 70% COLUMN ===== -->
      <div class="right-column">

        <!-- NEW: Right Column Tab Navigation -->
        <div class="right-nav-tabs">
          <!-- Order changed slightly to put To-Do first as it's common -->
          <button class="tab" data-target="todoCard">To-Do & History</button>
          <button class="tab" data-target="syllabusCard">Syllabus</button>
          <button class="tab" data-target="timetableCard">Timetable</button>
          <button class="tab" data-target="analyticsCard">Analytics</button>
          <button class="tab" data-target="stickyNotesCard">Sticky Notes</button>
          <button class="tab" data-target="calendarCard">Calendar</button>
        </div>

        <!-- NEW: Right Column Content Area -->
        <div class="right-content-area">

          <!-- To-Do Card (Moved to Right) -->
          <section class="card" id="todoCard">
            <div class="card-header">
              <div class="card-title">To-Do & History</div>
              <div class="row">
                <div class="tabs">
                  <div class="tab active" data-tab="todo">To-Do</div>
                  <div class="tab" data-tab="done">Completed</div>
                </div>
                <button class="icon-btn expand-btn" data-target="todoCard" title="Expand">‚Üó</button>
              </div>
            </div>
            <div class="card-body">
              <div class="row" id="todoInputRow">
                <input id="todoInput" type="text" placeholder="New task..." />
                <button id="addTask" class="accent">Add</button>
                <br>
              </div>
              <div id="todoList" class="list"></div>
              <div id="doneList" class="list" style="display:none"></div>
              <div class="row" id="doneActions" style="display:none;justify-content:flex-end">
                <button id="clearDone" class="ghost">Clear All</button>
              </div>
            </div>
          </section>

          <!-- Syllabus Card (Moved to Right) -->
          <section class="card" id="syllabusCard">
            <div class="card-header">
              <div class="row">
                <button id="syllabusNavPrev" class="icon-btn" title="Previous Page">·êä</button>
                <input id="syllabusPageTitle" type="text" style="width: 120px; text-align: center; font-weight: 600;"
                  value="Main" />
                <button id="syllabusNavNext" class="icon-btn" title="Next Page">·êÖ</button>
              </div>
              <div class="row">
                <button id="manageSyllabusPages" class="ghost">Manage</button>
                <button id="expandSyllabus" class="icon-btn expand-btn" data-target="syllabusCard"
                  title="Expand">‚Üó</button>
              </div>
            </div>
            <div class="card-body">
              <div class="row"
                style="padding: 0 4px 8px; border-bottom: 1px solid rgba(255,255,255,.04); margin-bottom: 8px;">
                <input id="subjectName" type="text" placeholder="New subject..." style="flex-grow:1" />
                <button id="addSubject" class="accent">Add Subject</button>
              </div>
              <div id="subjects" class="list"></div>
            </div>
          </section>

          <!-- Analytics Card (Moved to Right) -->
          <section class="card" id="analyticsCard">
            <div class="card-header">
              <div class="card-title">Performance Analytics</div>
              <div class="row">
                <div class="tabs analytics-tabs">
                  <div class="tab active" data-tab="syllabus">Syllabus</div>
                  <div class="tab" data-tab="todo">To-Do</div>
                  <div class="tab" data-tab="timetable">Timetable</div>
                </div>
                <select id="analyticsSubjectSelect"></select>
                <button class="icon-btn expand-btn" data-target="analyticsCard" title="Expand">‚Üó</button>
              </div>
            </div>
            <div class="card-body">
              <div class="canvas-wrap" style="min-height: 250px;"><canvas id="mainChart"></canvas></div>
            </div>
          </section>

          <!-- Timetable Card (Moved to Right) -->
          <section class="card" id="timetableCard">
            <div class="card-header">
              <div class="card-title">Weekly Timetable</div>
              <div class="row">
                <button id="uncheckTimetable" class="ghost" title="Uncheck all completed items">Uncheck</button>
                <button id="resetTimetable" class="ghost" title="Clear all activities">Reset</button>
                <button id="manageRows" class="ghost">Manage Rows</button>
                <button id="addBlock" class="accent">‚ûï</button>
                <button class="icon-btn expand-btn" data-target="timetableCard" title="Expand">‚Üó</button>
              </div>
            </div>
            <div class="card-body timetable">
              <table class="table" id="timetable"></table>
            </div>
          </section>

          <!-- Sticky Notes Card (Moved to Right) -->
          <section class="card" id="stickyNotesCard">
            <div class="card-header">
              <div class="card-title">Sticky Notes</div>
              <div class="row">
                <button class="icon-btn expand-btn" data-target="stickyNotesCard" title="Expand">‚Üó</button>
              </div>
            </div>
            <div class="card-body">
              <div id="stickyNotesCanvas"></div>
              <button id="addStickyNoteBtn" class="accent" title="Add New Sticky Note">Ôºã Note</button>
            </div>
          </section>

          <!-- Calendar Card (Moved to Right) -->
          <section class="card" id="calendarCard">
            <div class="card-header">
              <div class="card-title">History Calendar</div>
              <div class="row">
                <button class="icon-btn expand-btn" data-target="calendarCard" title="Expand">‚Üó</button>
              </div>
            </div>
            <div class="card-body calendar-container">
              <div class="calendar-header">
                <button id="calendarPrev" class="icon-btn">·êä</button>
                <div id="calendarMonthYear"></div>
                <button id="calendarNext" class="icon-btn">·êÖ</button>
              </div>
              <div class="calendar-body">
                <div class="calendar-grid" id="calendarGrid"></div>
              </div>
            </div>
          </section>

        </div> <!-- End .right-content-area -->
      </div> <!-- End .right-column -->
    </main>

    <!-- ===== FOOTER (Unchanged) ===== -->
    <div class="footer">100% local. Data stored in your browser. Schema v6.</div>
  </div>

  <!-- ===== SETTINGS BAR (MODIFIED) ===== -->
  <!-- This is now hidden by default and toggled by JS -->
  <div class="settings-bar" id="settingsBar">
    <!-- Theme group was REMOVED from here -->
    <div class="settings-group"> <!-- MOVED right -->
      <span class="badge">Accent:</span>
      <div id="accentPalette" class="row"></div>
    </div>
    <div class="settings-group">
      <span class="badge">Timer (Focus/Short/Long):</span>
      <input id="durFocus" type="number" min="1" style="width:60px" title="Focus Duration (minutes)">
      <input id="durShort" type="number" min="1" style="width:60px" title="Short Break (minutes)">
      <input id="durLong" type="number" min="1" style="width:60px" title="Long Break (minutes)">
      <button id="saveDur" class="accent">Save</button>
    </div>
    <div class="settings-group">
      <a href="About.html" id="aboutLink" class="settings-about-link">About Us</a> <!-- MOVED About link here -->
      <button id="importData" class="ghost" title="Import Data">üì•</button>
      <button id="exportData" class="ghost" title="Export Data">üì§</button>
      <button id="openResetSettings" class="ghost" title="Reset Settings">üîÑ</button>
    </div>
  </div>

  <!-- ===== NEW: Corner Controls (MODIFIED) ===== -->
  <div id="corner-controls" class="corner-controls">
    <button id="toggleSettingsBtn" class="ghost" title="Settings" style="font-size: 18px; padding: 8px; line-height: 1;">‚öôÔ∏è</button>
    <!-- REMOVED About link from here -->
  </div>


  <!-- ===== OVERLAYS (Unchanged) ===== -->
  <div id="modal" class="modal">
    <div id="modalCard" class="modal-card"></div>
  </div>
  <div id="context-menu" class="context-menu" aria-hidden="true"></div>
  <div id="chartTooltip"></div>
  <div id="dateTooltip"></div>
  <div id="timetableTooltip"></div>

  <!-- This style tag holds dynamically generated colors -->
  <style id="custom-colors-style"></style>


  <!-- ===== JAVASCRIPT ===== -->
  <script>
    // Main wrapper to ensure DOM is loaded before running script
    document.addEventListener('DOMContentLoaded', () => {

      /* ===== STATE MANAGEMENT (MODIFIED) ===== */
      const STATE_KEY = 'ppd_v6'; // Schema updated for new features
      const DEFAULT = () => ({
        version: 6,
        theme: 'dark',
        accent: '#6ea8fe',
        workspaces: [{
          name: 'Default',
          tasks: [],
          done: [],
          recurringTasks: [],
          lastRecurringCheck: null,
          syllabusPages: [{
            id: uid(),
            title: 'Main',
            subjects: []
          }],
          syllabusCurrentPage: 0,
          stats: {},
          timetable: {
            rows: ['09:00-10:00', '10:00-11:00', '11:00-12:00'],
            cells: {},
            weekStartDate: null,
            lastUsedColor: '#ffd36b'
          },
          stickyNotes: [],
          reminders: {}, // NEW: Added reminders
          timer: {
            dur: {
              focus: 25,
              short: 5,
              long: 15
            },
            currentCycle: 1,
            longBreakInterval: 4,
            autoStart: true
          },
          // MODIFIED: Added longest streak and unlocked badges
          focusStreak: {
            current: 0,
            lastSessionDate: null,
            dailyGoal: 4,
            longest: 0,
            totalDays: 0 // Added for badge
          },
          unlockedBadges: [],
          customColors: {}
        }],
        current: 0
      });

      // Loads the state from localStorage, performing migration if necessary
      function loadState() {
        try {
          const raw = localStorage.getItem(STATE_KEY);
          if (!raw) {
            const s = DEFAULT();
            localStorage.setItem(STATE_KEY, JSON.stringify(s));
            return s;
          }
          let obj = JSON.parse(raw);
          if (!obj.version || obj.version < 6) obj = migrate(obj);
          return obj;
        } catch (e) {
          console.error("Failed to load state:", e);
          localStorage.removeItem(STATE_KEY);
          const s = DEFAULT();
          localStorage.setItem(STATE_KEY, JSON.stringify(s));
          return s;
        }
      }

      // Migrates older data schemas to the current version
      function migrate(old) {
        console.warn("Migrating data from old version...");
        const s = DEFAULT();
        s.theme = old.theme || 'dark';
        s.accent = old.accent || '#6ea8fe';
        s.current = old.current || 0;
        s.workspaces = old.workspaces.map(ws => {
          const newWs = { ...DEFAULT().workspaces[0],
            ...ws
          };

          // NEW: Migrate timer settings for cycles and auto-start
          if (newWs.timer) {
            delete newWs.timer.alarmDur;
            delete newWs.timer.isMuted;
            newWs.timer.autoStart = true; // Force autoStart on for all users
            if (!newWs.timer.currentCycle) newWs.timer.currentCycle = 1;
            if (!newWs.timer.longBreakInterval) newWs.timer.longBreakInterval = 4;
          } else {
            newWs.timer = DEFAULT().workspaces[0].timer;
          }


          // --- Existing migrations from v5 ---
          if (!newWs.customColors) newWs.customColors = {};
          if (newWs.timetable && !newWs.timetable.lastUsedColor) newWs.timetable.lastUsedColor = '#ffd36b';
          if (!newWs.recurringTasks) newWs.recurringTasks = [];
          if (!newWs.lastRecurringCheck) newWs.lastRecurringCheck = null;

          if (newWs.tasks) {
            newWs.tasks.forEach(task => {
              task.subtasks = task.subtasks || [];
              if (typeof task.isCompletedToday === 'undefined') task.isCompletedToday = false;
            });
          }
          // MODIFIED: Migrate streak and badges
          if (!newWs.focusStreak) {
            newWs.focusStreak = {
              current: 0,
              lastSessionDate: null,
              dailyGoal: 4,
              longest: 0,
              totalDays: 0
            };
          } else {
            newWs.focusStreak.longest = newWs.focusStreak.longest || 0; // Add longest
            newWs.focusStreak.totalDays = Object.keys(newWs.stats || {}).length; // Calculate totalDays
          }
          if (!newWs.unlockedBadges) {
            newWs.unlockedBadges = []; // Add badges
          }
          if (!newWs.reminders) newWs.reminders = {}; // NEW: Add reminders migration
          // --- End new migration ---

          if (Array.isArray(ws.syllabus)) {
            newWs.syllabusPages = [{
              id: uid(),
              title: 'Main',
              subjects: ws.syllabus
            }];
            newWs.syllabusCurrentPage = 0;
            delete newWs.syllabus;
            newWs.syllabusPages[0].subjects.forEach(subj => {
              subj.topics.forEach(topic => {
                topic.completionDate = topic.done ? new Date().toISOString().slice(0, 10) : null;
                delete topic.done;
              });
            });
          }
          if (newWs.timetable && !newWs.timetable.weekStartDate) newWs.timetable.weekStartDate = getWeekStartDate(new Date());
          if (!newWs.stickyNotes) newWs.stickyNotes = [];
          if (ws.notes && typeof ws.notes === 'string' && ws.notes.trim().length > 0) {
            newWs.stickyNotes.push({
              id: uid(),
              x: 20,
              y: 20,
              text: `From Quick Notes:\n${ws.notes}`,
              files: [],
              color: '#ffcc66'
            });
            delete newWs.notes;
          }
          newWs.stickyNotes.forEach(note => {
            if (note.files && note.files.length > 0 && typeof note.files[0] === 'string') {
              note.files = note.files.map(fileUrl => {
                let displayName = fileUrl.split(/[\\/]/).pop() || fileUrl;
                return {
                  name: displayName,
                  url: fileUrl
                };
              });
            }
          });
          return newWs;
        });
        localStorage.setItem(STATE_KEY, JSON.stringify(s));
        alert('Your data has been updated to a new version!');
        return s;
      }

      // Saves the current state to localStorage
      function saveState() {
        try {
          localStorage.setItem(STATE_KEY, JSON.stringify(state));
        } catch (e) {
          alert('Save failed: storage quota?');
        }
      }

      // Auto backup function, currently disabled
      function backupAuto() {}

      let state = loadState();
      let calendarCurrentDate = new Date();

      function currentWS() {
        return state.workspaces[state.current];
      }

      function currentSyllabusPage() {
        const ws = currentWS();
        return ws.syllabusPages[ws.syllabusCurrentPage];
      }

      /* ===== HELPER UTILITIES (Unchanged) ===== */
      const $ = s => document.querySelector(s);
      const $$ = s => Array.from(document.querySelectorAll(s));

      function uid() {
        return Math.random().toString(36).slice(2, 9) + Date.now().toString(36).slice(-5);
      }

      function escapeHtml(s) {
        return (s || '').replace(/[&<>"']/g, m => ({
          '&': '&amp;',
          '<': '&lt;',
          '>': '&gt;',
          '"': '&quot;',
          "'": '&#x27;'
        } [m]));
      }

      function debounce(fn, ms = 200) {
        let t;
        return (...a) => {
          clearTimeout(t);
          t = setTimeout(() => fn(...a), ms);
        };
      }

      function autoResizeTextarea(textarea) {
        if (!textarea) return;
        textarea.style.height = 'auto';
        textarea.style.height = `${textarea.scrollHeight}px`;
      }

      function darkenHexColor(hex, amount) {
        if (!hex.startsWith('#')) return hex;
        let R = parseInt(hex.substring(1, 3), 16);
        let G = parseInt(hex.substring(3, 5), 16);
        let B = parseInt(hex.substring(5, 7), 16);
        R = parseInt(R * (1 - amount));
        G = parseInt(G * (1 - amount));
        B = parseInt(B * (1 - amount));
        R = (R < 255) ? R : 255;
        G = (G < 255) ? G : 255;
        B = (B < 255) ? B : 255;
        const RR = ((R.toString(16).length == 1) ? "0" + R.toString(16) : R.toString(16));
        const GG = ((G.toString(16).length == 1) ? "0" + G.toString(16) : G.toString(16));
        const BB = ((B.toString(16).length == 1) ? "0" + B.toString(16) : B.toString(16));
        return "#" + RR + GG + BB;
      }

      function getWeekStartDate(date) {
        const d = new Date(date);
        const day = d.getDay();
        const diff = d.getDate() - day + (day === 0 ? -6 : 1);
        return new Date(d.setDate(diff)).toISOString().slice(0, 10);
      }

      /* ===== EXPAND/MINIMIZE CARD (Unchanged) ===== */
      // This function remains robust and will work with the new layout
      function expandCard(cardId) {
        const card = $(`#${cardId}`);
        if (!card) return;
        card.classList.add('expanded');
        $('body').classList.add('modal-open');
        const expandBtn = card.querySelector('.expand-btn');
        if (expandBtn) expandBtn.style.display = 'none';

        const closeBtn = document.createElement('button');
        closeBtn.innerHTML = '‚úñ';
        closeBtn.className = 'icon-btn close-expanded';
        closeBtn.title = 'Minimize';

        const header = card.querySelector('.card-header');
        if (header && cardId !== 'stickyNotesCard') {
          header.querySelector('.row').appendChild(closeBtn);
        } else if (cardId === 'stickyNotesCard' || cardId === 'calendarCard') {
          closeBtn.style.position = 'absolute';
          closeBtn.style.top = '10px';
          closeBtn.style.right = '15px';
          closeBtn.style.zIndex = '150';
          card.appendChild(closeBtn);
        } else {
          closeBtn.style.position = 'absolute';
          closeBtn.style.top = '10px';
          closeBtn.style.right = '15px';
          closeBtn.style.zIndex = '150';
          card.appendChild(closeBtn);
        }
        closeBtn.onclick = () => minimizeCard(cardId);

        if (cardId === 'analyticsCard' || cardId === 'timetableCard') {
          setTimeout(() => {
            drawCharts();
          }, 50);
        }
        if (cardId === 'timerCard') {
          initTimerSettingsInputs();
        }
        if (cardId === 'streakInfoCard') {
          // Re-render streak info to show expanded data
          renderStreakInfo();
        }
      }

      function minimizeCard(cardId) {
        const card = $(`#${cardId}`);
        if (!card) return;
        card.classList.remove('expanded');
        $('body').classList.remove('modal-open');
        const expandBtn = card.querySelector('.expand-btn');
        if (expandBtn) expandBtn.style.display = '';
        card.querySelector('.close-expanded')?.remove();

        if (cardId === 'analyticsCard' || cardId === 'timetableCard') {
          setTimeout(() => {
            drawCharts();
          }, 50);
        }
        if (cardId === 'streakInfoCard') {
          // Re-render streak info to show collapsed data
          renderStreakInfo();
        }
      }

      // Modified to find ALL expand buttons, including new ones
      function initExpandButtons() {
        $$('.expand-btn').forEach(btn => {
          // Remove old listener to prevent duplicates
          btn.onclick = null;
          btn.addEventListener('click', (e) => {
            const targetId = e.currentTarget.dataset.target;
            expandCard(targetId);
          });
        });
      }

      /* ===== HEADER, THEME, WORKSPACES (MODIFIED) ===== */
      function tickClock() {
        const d = new Date();
        const timeString = d.toLocaleString('en-US', {
          hour: 'numeric',
          minute: 'numeric',
          hour12: true
        });
        $('#clock').textContent = `${timeString} ‚Ä¢ ${d.toDateString()}`;
        const h = d.getHours();
        $('#greet').textContent = h < 12 ? 'Good Morning' : h < 18 ? 'Good Afternoon' : 'Good Evening';
      }
      setInterval(tickClock, 1000);
      tickClock();

      function renderWorkspaceSelect() {
        const sel = $('#workspaceSelect');
        sel.innerHTML = '';
        state.workspaces.forEach((w, i) => {
          const o = document.createElement('option');
          o.value = i;
          o.textContent = w.name;
          sel.appendChild(o);
        });
        sel.value = state.current;
      }
      $('#workspaceSelect').addEventListener('change', e => {
        state.current = Number(e.target.value);
        saveState();
        renderAll();
      });
      $('#addWorkspace').addEventListener('click', () => {
        const name = prompt('Workspace name') || `WS ${state.workspaces.length + 1}`;
        state.workspaces.push(JSON.parse(JSON.stringify(DEFAULT().workspaces[0])));
        state.workspaces[state.workspaces.length - 1].name = name;
        state.current = state.workspaces.length - 1;
        saveState();
        renderAll();
      });
      $('#delWorkspace').addEventListener('click', () => {
        if (state.workspaces.length === 1) {
          alert('Cannot delete last workspace');
          return;
        }
        if (confirm(`Are you sure you want to delete workspace "${currentWS().name}"? This cannot be undone.`)) {
          state.workspaces.splice(state.current, 1);
          state.current = 0;
          saveState();
          renderAll();
        }
      });

      function applyTheme() {
        document.body.className = state.theme === 'light' ? 'light' : '';
        document.documentElement.style.setProperty('--accent', state.accent);
        document.documentElement.style.setProperty('--accent-2', state.accent);

        // NEW: Update theme toggle icon
        const themeIcon = (state.theme === 'light') ? 'üåô' : '‚òÄÔ∏è';
        const themeTitle = (state.theme === 'light') ? 'Switch to Dark Mode' : 'Switch to Light Mode';
        const themeBtn = $('#themeToggleBtn');
        if(themeBtn) {
          themeBtn.textContent = themeIcon;
          themeBtn.title = themeTitle;
        }

        applyCustomColors();
      }

      // NEW: Theme toggle button listener
      $('#themeToggleBtn').onclick = () => {
        state.theme = (state.theme === 'light') ? 'dark' : 'light';
        saveState();
        applyTheme();
      };

      // OLD theme buttons removed
      // $('#themeLight').onclick = () => { ... }; // REMOVED
      // $('#themeDark').onclick = () => { ... }; // REMOVED

      function applyCustomColors() {
        const ws = currentWS();
        if (!ws.customColors) ws.customColors = {};
        const styles = Object.entries(ws.customColors).map(([key, value]) => {
          if (!value) return '';
          const selectorMap = {
            todoCardAccent: '#todoCard',
            syllabusCardAccent: '#syllabusCard',
            timetableCardAccent: '#timetableCard',
            analyticsCardAccent: '#analyticsCard',
            timerCardAccent: '#timerCard',
          };

          if (key.endsWith('Accent')) { // Background color
            const selector = selectorMap[key];
            if (selector) {
              const baseSelector = `${state.theme === 'light' ? '.light' : ''} ${selector}`;
              return `
                        ${baseSelector} .accent, 
                        ${baseSelector} .tab.active { 
                            background: ${value} !important; 
                            background-image: none !important; 
                        }
                    `;
            }
          } else if (key.endsWith('AccentText')) { // Text color
            const baseKey = key.replace('Text', '');
            const selector = selectorMap[baseKey];
            if (selector) {
              const baseSelector = `${state.theme === 'light' ? '.light' : ''} ${selector}`;
              return `
                        ${baseSelector} .accent, 
                        ${baseSelector} .tab.active { 
                            color: ${value} !important;
                        }
                    `;
            }
          }
          return '';
        }).join('\n');

        $('#custom-colors-style').innerHTML = styles;
      }

      const defaultAccentChoices = ['#6ea8fe', '#8bd5ff', '#9b59b6', '#ff6b6b', '#59d18c', '#ffcc66', '#00d1b2', '#ff7ab2', '#36cfc9'];

      function renderAccentPalette() {
        const wrap = $('#accentPalette');
        if (!wrap) return;
        wrap.innerHTML = '';
        defaultAccentChoices.forEach(c => {
          const d = document.createElement('div');
          d.className = 'color-dot';
          d.style.background = c;
          d.title = c;
          d.onclick = () => {
            state.accent = c;
            saveState();
            applyTheme();
          };
          wrap.appendChild(d);
        });
        const expandBtn = document.createElement('button');
        expandBtn.className = 'ghost';
        expandBtn.textContent = 'üé®';
        expandBtn.title = 'More Colors & Options';
        expandBtn.onclick = openColorPickerModal;
        wrap.appendChild(expandBtn);
      }

      function openColorPickerModal() {
        const moreColors = [{
          name: "White",
          hex: "#ffffff"
        }, {
          name: "Silver",
          hex: "#bdc3c7"
        }, {
          name: "Gray",
          hex: "#7f8c8d"
        }, {
          name: "Black",
          hex: "#000000"
        }, {
          name: "Dark Background",
          hex: "#0f1115"
        }, {
          name: "Maroon",
          hex: "#c0392b"
        }, {
          name: "Red",
          hex: "#e74c3c"
        }, {
          name: "Orange",
          hex: "#e67e22"
        }, {
          name: "Yellow",
          hex: "#f1c40f"
        }, {
          name: "Olive",
          hex: "#808000"
        }, {
          name: "Lime",
          hex: "#2ecc71"
        }, {
          name: "Green",
          hex: "#27ae60"
        }, {
          name: "Aqua",
          hex: "#1abc9c"
        }, {
          name: "Teal",
          hex: "#16a085"
        }, {
          name: "Blue",
          hex: "#3498db"
        }, {
          name: "Navy",
          hex: "#2980b9"
        }, {
          name: "Fuchsia",
          hex: "#d35400"
        }, {
          name: "Purple",
          hex: "#8e44ad"
        }, {
          name: "Pink",
          hex: "#fd79a8"
        }, {
          name: "Hot Pink",
          hex: "#ff7675"
        }, {
          name: "Gold",
          hex: "#ffd700"
        }, {
          name: "Crimson",
          hex: "#dc143c"
        }, {
          name: "Brown",
          hex: "#964B00"
        }, {
          name: "Coral",
          hex: "#ff7f50"
        }, {
          name: "Indigo",
          hex: "#4B0082"
        }, {
          name: "Violet",
          hex: "#EE82EE"
        }, {
          name: "Turquoise",
          hex: "#40E0D0"
        }, {
          name: "Salmon",
          hex: "#FA8072"
        }, {
          name: "Plum",
          hex: "#DDA0DD"
        }];

        const customColorTargets = [{
          key: 'todoCardAccent',
          label: 'To-Do Buttons'
        }, {
          key: 'syllabusCardAccent',
          label: 'Syllabus Buttons'
        }, {
          key: 'timetableCardAccent',
          label: 'Timetable Buttons'
        }, {
          key: 'analyticsCardAccent',
          label: 'Analytics Buttons'
        }, {
          key: 'timerCardAccent',
          label: 'Timer Buttons'
        }, ];

        let colorGridHtml = moreColors.map(c => `<div class="color-dot" style="background:${c.hex}" title="${c.name}" data-hex="${c.hex}"></div>`).join('');

        let advancedOptionsHtml = customColorTargets.map(t => {
          const bgColor = currentWS().customColors[t.key] || '#000000'; // Default to black for input
          const textColorKey = t.key + 'Text';
          const textColor = currentWS().customColors[textColorKey] || '#000000'; // Default to black for input
          return `<div class="item">
                <label>${t.label}</label>
                <div class="row">
                    <label title="Background Color"><input type="color" data-key="${t.key}" value="${bgColor}"></label>
                    <label title="Text Color"><input type="color" data-key="${textColorKey}" value="${textColor}"></label>
                    <button class="ghost" data-reset-key="${t.key}" title="Reset to default">‚úñ</button>
                </div>
            </div>`;
        }).join('');

        const modalContent = html `
            <div class="color-picker-modal">
                <h3>Accent Color</h3>
                <div class="color-grid">${colorGridHtml}</div>
                <hr style="border-color: rgba(255,255,255,0.1); margin: 20px 0;">
                <h3>Advanced Options</h3>
                <p style="color:var(--muted); font-size: 12px; margin-top: -8px; margin-bottom: 12px;">Customize button colors for specific cards.</p>
                <div class="advanced-options list">${advancedOptionsHtml}</div>
                <button id="closeColorModal" class="accent" style="width: 100%; margin-top: 16px;">Done</button>
            </div>
        `;
        openModal(modalContent);

        $('#closeColorModal').onclick = closeModal;

        $('#modalCard .color-grid').addEventListener('click', e => {
          if (e.target.dataset.hex) {
            state.accent = e.target.dataset.hex;
            saveState();
            applyTheme();
          }
        });

        $('#modalCard .advanced-options').addEventListener('input', e => {
          if (e.target.type === 'color' && e.target.dataset.key) {
            const key = e.target.dataset.key;
            const value = e.target.value;
            currentWS().customColors[key] = value;
            saveState();
            applyCustomColors();
          }
        });

        $('#modalCard .advanced-options').addEventListener('click', e => {
          if (e.target.dataset.resetKey) {
            const key = e.target.dataset.resetKey;
            const textKey = key + 'Text';
            delete currentWS().customColors[key];
            delete currentWS().customColors[textKey];
            saveState();
            applyCustomColors();
            // Visually reset the color picker input
            const colorInputs = e.target.parentElement.querySelectorAll('input[type="color"]');
            colorInputs.forEach(input => input.value = '#000000');
          }
        });
      }

      /* ===== NEW: Settings Bar Toggle (MODIFIED) ===== */
      $('#toggleSettingsBtn').addEventListener('click', () => {
        const settingsBar = $('#settingsBar');
        // const aboutLink = $('#aboutLink'); // REMOVED
        const toggleBtn = $('#toggleSettingsBtn');
        const isVisible = settingsBar.classList.toggle('visible');

        if (isVisible) {
          // aboutLink.style.display = 'none'; // REMOVED
          toggleBtn.title = 'Close Settings';
        } else {
          // aboutLink.style.display = 'inline-block'; // REMOVED
          toggleBtn.title = 'Open Settings';
        }
      });

      /* ===== NEW: Right Column Tab Navigation ===== */
      function initRightColumnTabs() {
        const tabs = $$('.right-nav-tabs .tab');
        const cards = $$('.right-content-area .card');

        function showTab(targetId) {
          // Deactivate all
          tabs.forEach(t => t.classList.remove('active'));
          cards.forEach(c => c.classList.remove('active')); // .active has display:flex

          // Activate matching
          const tab = $(`.right-nav-tabs .tab[data-target="${targetId}"]`);
          const card = $(`#${targetId}`);

          if (tab) tab.classList.add('active');
          if (card) card.classList.add('active');

          // CRITICAL: Redraw charts/tables when shown
          if (targetId === 'analyticsCard' || targetId === 'timetableCard') {
            setTimeout(() => {
              drawCharts();
              // renderTimetable() is not needed, chart redraw is
            }, 50);
          }
        }

        tabs.forEach(tab => {
          tab.addEventListener('click', () => {
            showTab(tab.dataset.target);
          });
        });

        // Show the first tab by default
        if (tabs.length > 0) {
          showTab(tabs[0].dataset.target);
        }
      }


      /* ===== FOCUS TIMER (Unchanged) & STREAK (MODIFIED) ===== */
      let timerInt = null,
        remaining = 0,
        running = false,
        timerEndTime = 0;

      function modeDur(m) {
        return (currentWS().timer?.dur?.[m] ?? 25) * 60 * 1000;
      }

      function setModeUI() {
        const m = $('#mode').value;
        remaining = modeDur(m);
        updateDisplay(remaining);
        $('#timerStatus').textContent = 'Idle';
        updateCycleDisplay();
      }

      function updateDisplay(ms) {
        const totalSeconds = Math.max(0, Math.ceil(ms / 1000));
        const m = Math.floor(totalSeconds / 60);
        const s = totalSeconds % 60;
        $('#display').textContent = `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
        document.title = running ? `${$('#display').textContent} - Focus-Deck` : 'Focus-Deck';
      }

      function timerTick() {
        if (!running) return;
        remaining = timerEndTime - Date.now();
        if (remaining <= 0) {
          remaining = 0;
          updateDisplay(remaining);
          completeSession();
        } else {
          updateDisplay(remaining);
        }
      }

      function startTimer() {
        if (running) return;
        running = true;
        $('#timerStatus').textContent = `Running ${$('#mode').value}`;
        const duration = (remaining > 0 && remaining < modeDur($('#mode').value)) ? remaining : modeDur($('#mode').value);
        timerEndTime = Date.now() + duration;
        clearInterval(timerInt);
        timerInt = setInterval(timerTick, 500);
        timerTick();
      }

      function pauseTimer() {
        if (!running) return;
        running = false;
        clearInterval(timerInt);
        timerInt = null;
        remaining = timerEndTime - Date.now();
        $('#timerStatus').textContent = 'Paused';
        updateDisplay(remaining); // Update display one last time
      }

      function resetTimer() {
        pauseTimer();
        timerEndTime = 0;
        remaining = 0;
        const ws = currentWS();
        ws.timer.currentCycle = 1;
        saveState();
        setModeUI();
      }

      function flashDisplay() {
        const el = $('#display');
        let t = 0;
        const id = setInterval(() => {
          el.style.transform = (t++ % 2) ? 'scale(1.02)' : 'none';
          if (t > 6) {
            clearInterval(id);
            el.style.transform = 'none';
          }
        }, 180);
      }

      // MODIFIED: Update streak logic
      // This function is now the single source of truth for updating streak state.
      // It is called by completeSession, toggleTaskCompletion, toggleTopic, and timetable checkbox change.
      function updateStreak() {
        const ws = currentWS(); // Get workspace
        const streak = ws.focusStreak;
        const today = new Date().toISOString().slice(0, 10);

        // Ensure today's stats object exists before checking
        if (!ws.stats[today]) {
          ws.stats[today] = {
            tasks: 0,
            focus: 0
          };
          // This is a new day of activity, increment total days
          streak.totalDays = (streak.totalDays || 0) + 1;
        }

        // Now, check if the streak date needs updating
        if (streak.lastSessionDate !== today) {
          const yesterday = new Date();
          yesterday.setDate(yesterday.getDate() - 1);
          if (streak.lastSessionDate === yesterday.toISOString().slice(0, 10)) {
            // It's a consecutive day
            streak.current++;
          } else {
            // Streak was broken
            streak.current = 1;
          }
          streak.lastSessionDate = today;

          // NEW: Update longest streak
          if (streak.current > (streak.longest || 0)) {
            streak.longest = streak.current;
          }
        }
        // This function only updates the state object.
        // The calling function MUST call saveState() and render/check functions.
      }


      function renderStreakCounter() {
        const streak = currentWS().focusStreak;
        $('#streakCounter').innerHTML = `üî• ${streak.current}`;
        $('#streakCounter').title = `Current focus streak: ${streak.current} day(s). Goal: ${streak.dailyGoal} sessions/day.`;
      }

      // NEW: Render Streak Info Card
      function renderStreakInfo() {
        const ws = currentWS();
        if (!ws.focusStreak.longest) ws.focusStreak.longest = 0; // Ensure it exists
        if (!ws.focusStreak.totalDays) ws.focusStreak.totalDays = Object.keys(ws.stats).length; // Ensure it exists

        $('#currentStreakDisplay').textContent = `${ws.focusStreak.current} Day(s)`;
        $('#longestStreakDisplay').textContent = `${ws.focusStreak.longest} Day(s)`;
        $('#totalDaysDisplay').textContent = `${ws.focusStreak.totalDays} Day(s)`;
      }

      // MODIFIED: Complete session
      function completeSession() {
        clearInterval(timerInt);
        timerInt = null;
        running = false;
        remaining = 0;
        timerEndTime = 0;

        flashDisplay();
        $('#alarmSound').play().catch(() => {});

        const ws = currentWS();
        const currentMode = $('#mode').value;

        if (currentMode === 'focus') {
          updateStreak(); // This now handles stats creation and streak logic
          const key = new Date().toISOString().slice(0, 10);
          ws.stats[key].focus++; // We just need to increment the focus count
          
          if (ws.timer.currentCycle >= ws.timer.longBreakInterval) {
            $('#mode').value = 'long';
            ws.timer.currentCycle = 1;
          } else {
            $('#mode').value = 'short';
            ws.timer.currentCycle++;
          }
        } else {
          $('#mode').value = 'focus';
        }

        saveState();
        setModeUI();
        drawCharts();
        renderStreakCounter();
        // NEW: Update streak card and check for badges
        renderStreakInfo();
        checkAndUnlockBadges();

        if (ws.timer.autoStart) {
          startTimer(); // Auto-start
        }
      }

      function updateCycleDisplay() {
        const ws = currentWS();
        $('#cycleDisplay').textContent = `Cycle ${ws.timer.currentCycle} / ${ws.timer.longBreakInterval}`;
      }

      $('#mode').addEventListener('change', () => {
        pauseTimer();
        timerEndTime = 0;
        setModeUI();
      });
      $('#start').addEventListener('click', startTimer);
      $('#pause').addEventListener('click', pauseTimer);
      $('#reset').addEventListener('click', resetTimer);

      // --- Timer Settings in Expanded View ---
      function initTimerSettingsInputs() {
        const ws = currentWS();
        $('#longBreakInterval').value = ws.timer.longBreakInterval;
      }
      $('#saveTimerSettings').addEventListener('click', () => {
        const ws = currentWS();
        ws.timer.longBreakInterval = Math.max(1, Number($('#longBreakInterval').value));
        saveState();
        updateCycleDisplay();
        // Use modal instead of alert
        openModal(html`<p>Timer settings saved!</p><button id="closeAlertModal" class="accent">OK</button>`);
        $('#closeAlertModal').onclick = closeModal;
      });


      /* ===== NEW: Badges Logic ===== */
      const ALL_BADGES = {
        'streak1': {
          title: 'Beginner',
          icon: 'üå±',
          desc: 'Complete a 1-day focus streak.',
          unlock: (ws) => ws.focusStreak.current >= 1
        },
        'streak7': {
          title: 'Weekly Warrior',
          icon: 'üìÖ',
          desc: 'Complete a 7-day focus streak.',
          unlock: (ws) => ws.focusStreak.current >= 7
        },
        'streak30': {
          title: 'Month Master',
          icon: 'üóìÔ∏è',
          desc: 'Complete a 30-day focus streak.',
          unlock: (ws) => ws.focusStreak.current >= 30
        },
        'longest10': {
          title: 'Dedicated',
          icon: 'üéØ',
          desc: 'Achieve a 10-day longest streak.',
          unlock: (ws) => (ws.focusStreak.longest || 0) >= 10
        },
        'total10': {
          title: 'Getting Started',
          icon: 'üöÄ',
          desc: 'Use the app for 10 total days.',
          unlock: (ws) => (ws.focusStreak.totalDays || 0) >= 10
        },
        'total100': {
          title: 'Veteran',
          icon: 'üèÜ',
          desc: 'Use the app for 100 total days.',
          unlock: (ws) => (ws.focusStreak.totalDays || 0) >= 100
        }
      };

      function checkAndUnlockBadges() {
        const ws = currentWS();
        if (!ws.unlockedBadges) ws.unlockedBadges = [];
        let newBadgeUnlocked = false;
        let unlockedBadgeTitle = '';
        let unlockedBadgeIcon = '';

        Object.keys(ALL_BADGES).forEach(key => {
          if (!ws.unlockedBadges.includes(key)) {
            const badge = ALL_BADGES[key];
            if (badge.unlock(ws)) {
              ws.unlockedBadges.push(key);
              newBadgeUnlocked = true;
              unlockedBadgeTitle = badge.title;
              unlockedBadgeIcon = badge.icon;
            }
          }
        });

        if (newBadgeUnlocked) {
          saveState();
          renderBadges(); // Re-render just the badges
          // Use modal instead of alert
          openModal(html `
            <div style="text-align: center;">
                <h2 style="color: var(--ok);">Badge Unlocked!</h2>
                <p>You've earned the <strong>${escapeHtml(unlockedBadgeTitle)}</strong> badge!</p>
                <span style="font-size: 40px; margin: 10px 0; display: block;">${unlockedBadgeIcon}</span>
                <button id="closeBadgeModal" class="accent">Awesome!</button>
            </div>
          `);
          // Add listener to the new modal's button
          $('#closeBadgeModal').onclick = closeModal;
        }
      }

      function renderBadges() {
        const ws = currentWS();
        if (!ws.unlockedBadges) ws.unlockedBadges = [];
        const container = $('#badgesCard .card-body');
        if (!container) return; // Guard clause
        container.innerHTML = '';

        Object.keys(ALL_BADGES).forEach(key => {
          const badge = ALL_BADGES[key];
          const isUnlocked = ws.unlockedBadges.includes(key);

          const el = document.createElement('div');
          el.className = 'flip-card' + (isUnlocked ? '' : ' badge-locked');

          el.innerHTML = `
            <div class="flip-card-inner">
                <div class="flip-card-front">
                    <span class="badge-icon">${badge.icon}</span>
                    <span class="badge-title">${badge.title}</span>
                </div>
                <div class="flip-card-back">
                    <strong>${badge.title}</strong>
                    <p style="margin: 4px 0;">${escapeHtml(badge.desc)}</p>
                    ${isUnlocked ? '<span class="badge" style="background:var(--ok)">Unlocked!</span>' : '<span class="badge" style="background:var(--muted)">Locked</span>'}
                </div>
            </div>
        `;
          el.onclick = () => {
            el.classList.toggle('flipped');
          };
          container.appendChild(el);
        });
      }

      /* ===== TO-DO LIST & SUBTASKS (MODIFIED) ===== */
      function addTask() {
        const v = $('#todoInput').value.trim();
        if (!v) return;
        currentWS().tasks.push({
          id: uid(),
          text: v,
          created: Date.now(),
          subtasks: [],
          isCollapsed: true,
          isCompletedToday: false
        });
        saveState();
        $('#todoInput').value = '';
        renderTasks();
      }
      $('#addTask').addEventListener('click', addTask);
      $('#todoInput').addEventListener('keydown', e => {
        if (e.key === 'Enter') addTask();
      });

      function addSubtask(taskId) {
        const name = prompt("New subtask name:");
        if (!name || !name.trim()) return;
        const task = currentWS().tasks.find(t => t.id === taskId);
        if (task) {
          if (!task.subtasks) task.subtasks = [];
          task.subtasks.push({
            id: uid(),
            text: name.trim(),
            done: false
          });
          task.isCollapsed = false; // Expand when adding a new subtask
          saveState();
          renderTasks();
        }
      }

      function editSubtask(taskId, subtaskId) {
        const task = currentWS().tasks.find(t => t.id === taskId);
        if (!task) return;
        const subtask = task.subtasks.find(st => st.id === subtaskId);
        if (!subtask) return;

        const newText = prompt('Edit subtask:', subtask.text);
        if (newText !== null && newText.trim() !== '') {
          subtask.text = newText.trim();
          saveState();
          renderTasks();
        }
      }

      function deleteSubtask(taskId, subtaskId) {
        const task = currentWS().tasks.find(t => t.id === taskId);
        if (task && confirm('Are you sure you want to delete this subtask?')) {
          task.subtasks = task.subtasks.filter(st => st.id !== subtaskId);
          saveState();
          renderTasks();
        }
      }


      function toggleSubtask(taskId, subtaskId) {
        const task = currentWS().tasks.find(t => t.id === taskId);
        if (task) {
          const subtask = task.subtasks.find(st => st.id === subtaskId);
          if (subtask) {
            subtask.done = !subtask.done;
            saveState();
            renderTasks();
          }
        }
      }

      // MODIFIED: This function now calls updateStreak()
      function toggleTaskCompletion(taskId, isChecked) {
        const ws = currentWS();
        const taskIndex = ws.tasks.findIndex(t => t.id === taskId);
        if (taskIndex === -1) return; // Task not found, exit

        const task = ws.tasks[taskIndex];
        const key = new Date().toISOString().slice(0, 10);

        if (task.recurringId) {
          task.isCompletedToday = isChecked;
          if (isChecked) {
            updateStreak(); // Call streak logic
            ws.stats[key].tasks++; // Increment task count (updateStreak ensures ws.stats[key] exists)
            ws.done.unshift({
              id: uid(),
              text: task.text,
              when: Date.now(),
              recurringId: task.recurringId
            });
          } else {
            // Un-checking a recurring task
            const today = new Date().toISOString().slice(0, 10);
            const doneIndex = ws.done.findIndex(d =>
              d.recurringId === task.recurringId &&
              new Date(d.when).toISOString().slice(0, 10) === today
            );

            if (doneIndex > -1) {
              ws.done.splice(doneIndex, 1);
              if (ws.stats[key] && ws.stats[key].tasks > 0) {
                ws.stats[key].tasks--;
              }
            }
          }
        } else {
          // Non-recurring task
          if (isChecked) {
            updateStreak(); // Call streak logic
            ws.stats[key].tasks++; // Increment task count
            const [t] = ws.tasks.splice(taskIndex, 1);
            ws.done.unshift({
              id: uid(),
              text: t.text,
              when: Date.now()
            });
          }
          // Note: Un-checking a non-recurring task is not supported by the UI (it moves to 'Done')
        }

        saveState();
        renderTasks();
        drawCharts();
        
        // Add rendering for streak and check for badges IF a task was completed
        if(isChecked) {
            renderStreakCounter();
            renderStreakInfo();
            checkAndUnlockBadges();
        }
      }


      function deleteTask(id, done = false) {
        const ws = currentWS();
        const arr = done ? ws.done : ws.tasks;
        const i = arr.findIndex(x => x.id === id);
        if (i < 0) return;

        const task = arr[i];

        if (!done && task.recurringId) {
          openModal(html `
                <h3>Delete Recurring Task</h3>
                <p>This is a recurring task. How would you like to delete it?</p>
                <div class="row" style="justify-content: flex-end;">
                    <button id="delOnce" class="ghost">Delete Just This Once</button>
                    <button id="delPerm" class="accent">Stop Recurring & Delete All</button>
                </div>
            `);
          $('#delOnce').onclick = () => {
            arr.splice(i, 1);
            saveState();
            renderTasks();
            closeModal();
          };
          $('#delPerm').onclick = () => {
            ws.recurringTasks = ws.recurringTasks.filter(rt => rt.id !== task.recurringId);
            ws.tasks = ws.tasks.filter(t => t.recurringId !== task.recurringId);
            ws.done = ws.done.filter(t => t.recurringId !== task.recurringId);
            saveState();
            renderTasks();
            closeModal();
          }
        } else {
          arr.splice(i, 1);
          saveState();
          renderTasks();
        }
      }

      function editTask(id) {
        const ws = currentWS();
        const t = ws.tasks.find(x => x.id === id) || ws.done.find(x => x.id === id);
        if (!t) return;
        const nv = prompt('Edit', t.text);
        if (nv === null) return;
        t.text = nv.trim();
        saveState();
        renderTasks();
      }

      let dragSrc = null;
      const ctxMenu = $('#context-menu');

      function showContextMenu(x, y, items) {
        ctxMenu.innerHTML = '';
        items.forEach(it => {
          const b = document.createElement('button');
          b.textContent = it.label;
          b.onclick = () => {
            try {
              it.action();
            } catch (e) {
              console.error(e);
            }
            hideContextMenu();
          };
          ctxMenu.appendChild(b);
        });
        const mx = window.innerWidth - 12 - ctxMenu.offsetWidth;
        const my = window.innerHeight - 12 - ctxMenu.offsetHeight;
        ctxMenu.style.left = Math.min(x, mx) + 'px';
        ctxMenu.style.top = Math.min(y, my) + 'px';
        ctxMenu.style.display = 'flex';
        ctxMenu.setAttribute('aria-hidden', 'true');
      }

      function hideContextMenu() {
        ctxMenu.style.display = 'none';
        ctxMenu.setAttribute('aria-hidden', 'true');
      }
      document.addEventListener('click', e => {
        if (!ctxMenu.contains(e.target)) hideContextMenu();
      });

      function renderTasks() {
        const ws = currentWS();
        const todo = $('#todoList');
        const done = $('#doneList');
        todo.innerHTML = '';
        done.innerHTML = '';

        ws.tasks.forEach(t => {
          if (typeof t.isCollapsed === 'undefined') t.isCollapsed = true;

          const isRecurring = !!t.recurringId;
          const isCompletedRec = isRecurring && t.isCompletedToday;

          const el = document.createElement('div');
          el.className = 'task-item' + (t.isCollapsed ? ' collapsed' : '') + (isCompletedRec ? ' recurring-completed' : '');
          el.dataset.id = t.id;

          const doneSubtasks = (t.subtasks || []).filter(st => st.done).length;
          const totalSubtasks = (t.subtasks || []).length;
          const progress = totalSubtasks > 0 ? (doneSubtasks / totalSubtasks) * 100 : 0;

          let subtaskHTML = '';
          if (totalSubtasks > 0) {
            subtaskHTML = '<div class="list" style="padding-left: 20px; margin-top: 8px;">';
            t.subtasks.forEach(st => {
              subtaskHTML += `
                <div class="item" style="padding: 4px; grid-template-columns: auto 1fr auto;">
                    <input type="checkbox" ${st.done ? 'checked' : ''} data-task-id="${t.id}" data-subtask-id="${st.id}">
                    <div class="text">${escapeHtml(st.text)}</div>
                    <div class="row">
                        <button class="icon-btn edit-subtask-btn" data-subtask-id="${st.id}" title="Edit Subtask">‚úé</button>
                        <button class="icon-btn delete-subtask-btn" data-subtask-id="${st.id}" title="Delete Subtask">üóë</button>
                    </div>
                </div>`;
            });
            subtaskHTML += '</div>';
          }

          el.innerHTML = `
            <div class="item" style="padding: 8px; background: transparent; border: none; grid-template-columns: auto 1fr auto auto;">
                <input type="checkbox" title="Complete task" ${isCompletedRec ? 'checked' : ''}>
                <div class="text" title="${escapeHtml(t.text)}">${isRecurring ? 'üìå ' : ''}${escapeHtml(t.text)}</div>
                <div class="row">
                    ${totalSubtasks > 0 ? `<button class="icon-btn toggle-subtasks-btn" title="Toggle Subtasks">${t.isCollapsed ? '‚ñæ' : '‚ñ¥'}</button>` : ''}
                    <button class="icon-btn toggle-recurring-btn" title="${isRecurring ? 'Make One-Time (Unpin)' : 'Make Recurring (Pin)'}" style="${isRecurring ? `color: var(--accent);` : ''}">üìå</button>
                    <button class="icon-btn add-subtask-btn" title="Add Subtask">‚ûï</button>
                    <button class="icon-btn edit-task-btn" title="Edit">‚úé</button>
                    <button class="icon-btn delete-task-btn" title="Delete">üóë</button>
                </div>
                 <div class="drag-handle" draggable="true">::</div>
            </div>
            ${totalSubtasks > 0 ? `<div class="progress" style="margin: 0 8px 8px;"><span style="width: ${progress}%"></span></div>` : ''}
            <div class="subtask-list-container" style="padding: 0 8px 8px;">${subtaskHTML}</div>
        `;

          el.querySelector('input[type="checkbox"]').onchange = function() {
            toggleTaskCompletion(t.id, this.checked)
          };
          el.querySelector('.toggle-recurring-btn').onclick = () => toggleRecurring(t.id);
          el.querySelector('.add-subtask-btn').onclick = () => addSubtask(t.id);
          el.querySelector('.edit-task-btn').onclick = () => editTask(t.id);
          el.querySelector('.delete-task-btn').onclick = () => deleteTask(t.id);

          const toggleSubtasksBtn = el.querySelector('.toggle-subtasks-btn');
          if (toggleSubtasksBtn) {
            toggleSubtasksBtn.onclick = (e) => {
              e.stopPropagation();
              t.isCollapsed = !t.isCollapsed;
              saveState();
              renderTasks();
            };
          }

          el.querySelectorAll('.edit-subtask-btn').forEach(btn => {
            btn.onclick = () => editSubtask(t.id, btn.dataset.subtaskId);
          });
          el.querySelectorAll('.delete-subtask-btn').forEach(btn => {
            btn.onclick = () => deleteSubtask(t.id, btn.dataset.subtaskId);
          });

          el.querySelectorAll('.subtask-list-container input[type="checkbox"]').forEach(subtaskCheckbox => {
            subtaskCheckbox.onchange = (e) => {
              toggleSubtask(e.target.dataset.taskId, e.target.dataset.subtaskId);
            };
          });

          el.querySelector('.drag-handle').addEventListener('dragstart', e => {
            dragSrc = el;
            el.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.stopPropagation(); // Prevent parent drag from firing
          });
          el.addEventListener('dragend', e => {
            if (dragSrc) dragSrc.classList.remove('dragging');
            dragSrc = null;
            saveOrder();
          });
          el.addEventListener('dragover', e => {
            e.preventDefault();
            const target = e.currentTarget;
            if (target === dragSrc) return;
            const rect = target.getBoundingClientRect();
            const after = (e.clientY - rect.top) > rect.height / 2;
            target.parentNode.insertBefore(dragSrc, after ? target.nextSibling : target);
          });
          todo.appendChild(el);
        });

        ws.done.forEach(t => {
          const el = document.createElement('div');
          el.className = 'item';
          const when = new Date(t.when).toLocaleString();
          el.innerHTML = `<span class="badge">‚úì</span><div class="text" title="${escapeHtml(t.text)}">${t.recurringId ? 'üìå ' : ''}${escapeHtml(t.text)}</div><span class="badge" title="${when}">${when}</span><div><button class="icon-btn" title="Delete">üóë</button></div>`;
          el.querySelector('button').onclick = () => deleteTask(t.id, true);
          done.appendChild(el);
        });
        filterTodo($('#globalSearch').value.trim().toLowerCase());
      }

      function saveOrder() {
        const wrap = $('#todoList');
        const ids = Array.from(wrap.children).map(c => c.dataset.id);
        const ws = currentWS();
        ws.tasks = ids.map(id => ws.tasks.find(t => t.id === id)).filter(Boolean);
        saveState();
      }
      $$('#todoCard .tab').forEach(tab => {
        tab.onclick = () => {
          $$('#todoCard .tab').forEach(t => t.classList.remove('active'));
          tab.classList.add('active');
          const isTodo = tab.dataset.tab === 'todo';
          $('#todoInputRow').style.display = isTodo ? '' : 'none';
          $('#todoList').style.display = isTodo ? '' : 'none';
          $('#doneList').style.display = isTodo ? 'none' : '';
          $('#doneActions').style.display = isTodo ? 'none' : 'flex';
        };
      });
      $('#clearDone').onclick = () => {
        currentWS().done = [];
        saveState();
        renderTasks();
      };

      /* ===== RECURRING TASKS (Unchanged) ===== */
      function toggleRecurring(taskId) {
        const ws = currentWS();
        const task = ws.tasks.find(t => t.id === taskId);
        if (!task) return;

        if (task.recurringId) {
          const recurringTask = ws.recurringTasks.find(rt => rt.id === task.recurringId);
          if (recurringTask) {
            ws.recurringTasks = ws.recurringTasks.filter(rt => rt.id !== task.recurringId);
          }
          delete task.recurringId;
          task.isCompletedToday = false;
        } else {
          const newRecurring = {
            id: uid(),
            text: task.text
          };
          ws.recurringTasks.push(newRecurring);
          task.recurringId = newRecurring.id;
        }
        saveState();
        renderTasks();
      }

      function checkAndResetRecurringTasks() {
        const ws = currentWS();
        if (!ws.recurringTasks) ws.recurringTasks = [];

        const today = new Date().toISOString().slice(0, 10);

        if (ws.lastRecurringCheck !== today) {
          let changed = false;

          ws.tasks.forEach(task => {
            if (task.recurringId && task.isCompletedToday) {
              task.isCompletedToday = false; // Reset for the new day
              changed = true;
            }
          });

          ws.recurringTasks.forEach(recurringTask => {
            const existsInTodo = ws.tasks.some(t => t.recurringId === recurringTask.id);
            if (!existsInTodo) {
              ws.tasks.push({
                id: uid(),
                text: recurringTask.text,
                created: Date.now(),
                subtasks: [],
                recurringId: recurringTask.id,
                isCollapsed: true,
                isCompletedToday: false
              });
              changed = true;
            }
          });

          ws.lastRecurringCheck = today;
          if (changed) {
            saveState();
            renderTasks();
          }
        }
      }

      /* ===== REMINDER FUNCTIONS (NEW) ===== */
      function getReminders(dateString) {
        const ws = currentWS();
        if (!ws.reminders) ws.reminders = {};
        return ws.reminders[dateString] || [];
      }

      function addReminder(dateString, text) {
        const ws = currentWS();
        if (!ws.reminders) ws.reminders = {};
        if (!ws.reminders[dateString]) ws.reminders[dateString] = [];
        ws.reminders[dateString].push({
          id: uid(),
          text: text.trim()
        });
        saveState();
        renderCalendar(); // Redraw calendar to show indicator
      }

      function editReminder(dateString, id, newText) {
        const ws = currentWS();
        if (!ws.reminders || !ws.reminders[dateString]) return;
        const reminder = ws.reminders[dateString].find(r => r.id === id);
        if (reminder) {
          reminder.text = newText.trim();
          saveState();
        }
      }

      function deleteReminder(dateString, id) {
        const ws = currentWS();
        if (!ws.reminders || !ws.reminders[dateString]) return;
        ws.reminders[dateString] = ws.reminders[dateString].filter(r => r.id !== id);
        // If no reminders left, delete the date entry
        if (ws.reminders[dateString].length === 0) {
          delete ws.reminders[dateString];
        }
        saveState();
        renderCalendar(); // Redraw calendar to update indicator
      }

      function hasReminderForDate(dateString) {
        const ws = currentWS();
        return ws.reminders && ws.reminders[dateString] && ws.reminders[dateString].length > 0;
      }

      function openReminderModal(dateString) {
        const modalContent = html `
        <h3>Reminders for ${dateString}</h3>
        <div id="reminderListModal" class="list" style="max-height: 250px; overflow-y: auto; margin-bottom: 16px;">
            <!-- Reminders will be rendered here -->
        </div>
        <div class="column">
            <input id="newReminderText" type="text" placeholder="New reminder...">
            <button id="addReminderBtn" class="accent">Add Reminder</button>
        </div>
      `;
        openModal(modalContent);

        const listEl = $('#reminderListModal');
        renderReminderListInModal(dateString, listEl);

        $('#addReminderBtn').onclick = () => {
          const input = $('#newReminderText');
          const text = input.value.trim();
          if (text) {
            addReminder(dateString, text);
            input.value = '';
            renderReminderListInModal(dateString, listEl); // Re-render list
          }
        };

        $('#newReminderText').onkeydown = (e) => {
          if (e.key === 'Enter') {
            $('#addReminderBtn').click();
          }
        };
      }

      function renderReminderListInModal(dateString, listEl) {
        const reminders = getReminders(dateString);
        if (reminders.length === 0) {
          listEl.innerHTML = `<p style="color: var(--muted); text-align: center;">No reminders for this date.</p>`;
          return;
        }

        listEl.innerHTML = '';
        reminders.forEach(r => {
          const item = document.createElement('div');
          item.className = 'item';
          item.innerHTML = `
            <div class="text">${escapeHtml(r.text)}</div>
            <div class="row">
                <button class="icon-btn edit-reminder-btn" title="Edit">‚úé</button>
                <button class="icon-btn delete-reminder-btn" title="Delete">üóë</button>
            </div>
        `;

          item.querySelector('.edit-reminder-btn').onclick = () => {
            const newText = prompt('Edit reminder:', r.text);
            if (newText !== null && newText.trim() !== '') {
              editReminder(dateString, r.id, newText);
              renderReminderListInModal(dateString, listEl); // Re-render list
            }
          };

          item.querySelector('.delete-reminder-btn').onclick = () => {
            // No confirm() per user rules.
            deleteReminder(dateString, r.id);
            renderReminderListInModal(dateString, listEl); // Re-render list
          };
          listEl.appendChild(item);
        });
      }
      /* ===== END REMINDER FUNCTIONS ===== */


      /* ===== SYLLABUS (MODIFIED) ===== */
      function addSubject() {
        const v = $('#subjectName').value.trim();
        if (!v) return;
        currentSyllabusPage().subjects.push({
          id: uid(),
          name: v,
          topics: []
        });
        saveState();
        $('#subjectName').value = '';
        renderSyllabus();
        populateAnalyticsSubjectSelect();
      }
      $('#addSubject').addEventListener('click', addSubject);
      $('#subjectName').addEventListener('keydown', e => {
        if (e.key === 'Enter') addSubject();
      });

      function addTopic(subjId, name) {
        if (!name) return;
        const s = currentSyllabusPage().subjects.find(x => x.id === subjId);
        if (!s) return;
        s.topics.push({
          id: uid(),
          name,
          completionDate: null
        });
        saveState();
        renderSyllabus();
      }

      // MODIFIED: This function now calls updateStreak()
      function toggleTopic(subjId, topicId) {
        const s = currentSyllabusPage().subjects.find(x => x.id === subjId);
        if (!s) return;
        const t = s.topics.find(x => x.id === topicId);
        if (!t) return;
        
        const wasCompleted = !!t.completionDate;
        t.completionDate = wasCompleted ? null : new Date().toISOString().slice(0, 10);
        
        let topicWasJustCompleted = !wasCompleted; // True if we just set the date

        if (topicWasJustCompleted) {
            updateStreak(); // <-- ADDED
            // We could also increment a syllabus-specific counter in stats if we wanted
            // const key = new Date().toISOString().slice(0, 10);
            // if (!currentWS().stats[key].syllabus) currentWS().stats[key].syllabus = 0;
            // currentWS().stats[key].syllabus++;
            // For now, just triggering the streak is enough as per user request.
        }

        saveState();
        renderSyllabus();
        drawCharts();
        renderCalendar();

        // Add rendering for streak and check for badges
        if(topicWasJustCompleted) {
            renderStreakCounter();
            renderStreakInfo();
            checkAndUnlockBadges();
        }
      }

      function renderSyllabus() {
        const page = currentSyllabusPage();
        const wrap = $('#subjects');
        wrap.innerHTML = '';
        page.subjects.forEach(s => {
          if (typeof s.isCollapsed === 'undefined') s.isCollapsed = true;
          const doneCnt = s.topics.filter(t => t.completionDate).length;
          const total = s.topics.length;
          const pct = total > 0 ? Math.round(doneCnt / total * 100) : 0;

          const el = document.createElement('div');
          el.className = 'subj' + (s.isCollapsed ? ' collapsed' : '');
          el.dataset.id = s.id;

          el.innerHTML = `<div class="subj-header item" style="padding: 8px; background: transparent; border: none; grid-template-columns: auto 1fr auto;">
            <div class="drag-handle" draggable="true">::</div>
            <div style="display:flex;gap:12px;align-items:center; overflow:hidden;">
                <div style="width:40px;height:40px; flex-shrink: 0;">
                    <svg viewBox="0 0 36 36" style="width:100%;height:100%;transform:rotate(-90deg);">
                        <circle cx="18" cy="18" r="15.9155" fill="none" stroke="rgba(255,255,255,.06)" stroke-width="3.8"></circle>
                        <circle cx="18" cy="18" r="15.9155" fill="none" stroke="var(--accent)" stroke-width="3.8" stroke-dasharray="${pct}, 100" pathLength="100" style="transition: stroke-dasharray 0.3s ease;"></circle>
                    </svg>
                </div>
                 <div class="subj-title" style="font-weight:600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${escapeHtml(s.name)}</div>
            </div>
            <div style="display:flex;gap:8px;align-items:center">
                <div class="badge">${pct}%</div>
                <button class="icon-btn subj-add" title="Add Topic">Ôºã</button>
                <button class="icon-btn subj-rename" title="Rename Subject">‚úé</button>
                <button class="icon-btn subj-del" title="Delete Subject">üóë</button>
                <button class="icon-btn toggle-topics-btn" title="Toggle Topics">${s.isCollapsed ? '‚ñæ' : '‚ñ¥'}</button>
            </div>
        </div>
        <div class="topics" style="padding:8px 4px"></div>`;

          const topicsEl = el.querySelector('.topics');
          s.topics.forEach(t => {
            const row = document.createElement('div');
            row.className = 'topic item';
            row.innerHTML = `<input type="checkbox" ${t.completionDate ? 'checked' : ''} data-sid="${s.id}" data-tid="${t.id}"><div class="text">${escapeHtml(t.name)}</div><div style="display:flex;gap:6px"><button class="icon-btn">‚úé</button><button class="icon-btn">üóë</button></div>`;
            row.querySelector('input').onchange = (e) => {
              const subjId = e.target.dataset.sid;
              const topicId = e.target.dataset.tid;
              toggleTopic(subjId, topicId);
            };
            row.querySelectorAll('button')[0].onclick = () => {
              const nv = prompt('Edit topic', t.name);
              if (nv === null) return;
              t.name = nv.trim();
              saveState();
              renderSyllabus();
            };
            row.querySelectorAll('button')[1].onclick = () => {
              s.topics = s.topics.filter(x => x.id !== t.id);
              saveState();
              renderSyllabus();
              populateAnalyticsSubjectSelect();
            };
            topicsEl.appendChild(row);
          });

          const header = el.querySelector('.subj-header');

          header.addEventListener('click', (e) => {
            if (e.target.closest('button') || e.target.classList.contains('drag-handle')) return;
            s.isCollapsed = !s.isCollapsed;
            saveState();
            renderSyllabus();
          });

          el.querySelector('.toggle-topics-btn').onclick = (e) => {
            e.stopPropagation();
            s.isCollapsed = !s.isCollapsed;
            saveState();
            renderSyllabus();
          };

          el.querySelector('.drag-handle').addEventListener('dragstart', e => {
            dragSrc = el;
            el.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.stopPropagation();
          });
          el.addEventListener('dragend', e => {
            if (dragSrc) dragSrc.classList.remove('dragging');
            dragSrc = null;
            saveSyllabusOrder();
          });
          el.addEventListener('dragover', e => {
            e.preventDefault();
            const target = e.currentTarget;
            if (target === dragSrc) return;
            const rect = target.getBoundingClientRect();
            const after = (e.clientY - rect.top) > rect.height / 2;
            target.parentNode.insertBefore(dragSrc, after ? target.nextSibling : target);
          });

          el.querySelector('.subj-add').onclick = (e) => {
            e.stopPropagation();
            const name = prompt('Topic name');
            if (name) addTopic(s.id, name);
          };
          el.querySelector('.subj-rename').onclick = (e) => {
            e.stopPropagation();
            const nv = prompt('Rename subject', s.name);
            if (nv === null) return;
            s.name = nv.trim();
            saveState();
            renderSyllabus();
            populateAnalyticsSubjectSelect();
          };
          el.querySelector('.subj-del').onclick = (e) => {
            e.stopPropagation();
            page.subjects = page.subjects.filter(x => x.id !== s.id);
            saveState();
            renderSyllabus();
            populateAnalyticsSubjectSelect();
          };
          wrap.appendChild(el);
        });
        filterSyllabus($('#globalSearch').value.trim().toLowerCase());
      }

      function saveSyllabusOrder() {
        const wrap = $('#subjects');
        const ids = Array.from(wrap.children).map(c => c.dataset.id);
        const page = currentSyllabusPage();
        page.subjects = ids.map(id => page.subjects.find(s => s.id === id)).filter(Boolean);
        saveState();
      }

      function renderSyllabusNav() {
        const ws = currentWS();
        const pageTitleInput = $('#syllabusPageTitle');
        pageTitleInput.value = currentSyllabusPage().title;
        pageTitleInput.title = currentSyllabusPage().title;
        $('#syllabusNavPrev').disabled = ws.syllabusCurrentPage === 0;
        $('#syllabusNavNext').disabled = ws.syllabusCurrentPage >= ws.syllabusPages.length - 1;
      }

      function navigateSyllabus(dir) {
        const ws = currentWS();
        const newIndex = ws.syllabusCurrentPage + dir;
        if (newIndex >= 0 && newIndex < ws.syllabusPages.length) {
          ws.syllabusCurrentPage = newIndex;
          saveState();
          renderSyllabusNav();
          renderSyllabus();
          populateAnalyticsSubjectSelect();
          drawCharts();
        }
      }
      $('#syllabusNavPrev').addEventListener('click', () => navigateSyllabus(-1));
      $('#syllabusNavNext').addEventListener('click', () => navigateSyllabus(1));
      $('#syllabusPageTitle').addEventListener('change', e => {
        currentSyllabusPage().title = e.target.value.trim();
        saveState();
        renderSyllabusNav();
      });

      $('#manageSyllabusPages').addEventListener('click', () => {
        const ws = currentWS();
        openModal(html `<h3>Manage Syllabus Pages</h3><div id="pagesWrap" class="list" style="max-height: 50vh; overflow-y: auto;"></div><div class="row" style="margin-top:10px"><button id="addPage" class="accent">Add New Page</button></div>`);
        const pagesWrap = $('#pagesWrap');

        function paint() {
          pagesWrap.innerHTML = '';
          ws.syllabusPages.forEach((p, i) => {
            const row = document.createElement('div');
            row.className = 'item';
            row.innerHTML = `<span class="badge">#${i + 1}</span><div class="text">${escapeHtml(p.title)}</div><button class="icon-btn" ${i === 0 ? 'disabled' : ''}>üóë</button>`;
            row.querySelector('button').onclick = () => {
              ws.syllabusPages.splice(i, 1);
              if (ws.syllabusCurrentPage >= i) ws.syllabusCurrentPage = Math.max(0, ws.syllabusCurrentPage - 1);
              saveState();
              navigateSyllabus(0);
              paint();
            };
            pagesWrap.appendChild(row);
          });
        }
        paint();
        $('#addPage').onclick = () => {
          const name = prompt('New page name', `Page ${ws.syllabusPages.length + 1}`);
          if (!name) return;
          ws.syllabusPages.push({
            id: uid(),
            title: name,
            subjects: []
          });
          saveState();
          paint();
          renderSyllabusNav();
        };
      });

      /* ===== PERFORMANCE ANALYTICS (Unchanged) ===== */
      let barChartHoverData = {
        rects: [],
        canvas: null
      };
      const chartTooltip = $('#chartTooltip');

      function draw3dDonutChart(canvas, chartData, title) {
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);
        ctx.clearRect(0, 0, rect.width, rect.height);

        canvas.onmousemove = null;
        canvas.onmouseout = null;

        const w = rect.width;
        const h = rect.height;
        const centerX = w / 2;
        const centerY = h / 2;
        const radius = Math.min(w, h) * 0.35;
        const innerRadius = radius * 0.6;
        const depth = 10;

        const completedColor = getComputedStyle(document.documentElement).getPropertyValue('--ok').trim();
        const remainingColor = getComputedStyle(document.documentElement).getPropertyValue('--danger').trim();
        const panelColor = getComputedStyle(document.documentElement).getPropertyValue('--panel').trim();
        const textColor = getComputedStyle(document.documentElement).getPropertyValue('--text').trim();

        const remaining = chartData.total - chartData.completed;
        const percentage = chartData.total > 0 ? Math.round((chartData.completed / chartData.total) * 100) : 0;

        const slices = [{
          label: 'Completed',
          value: chartData.completed,
          color: completedColor
        }, {
          label: 'Remaining',
          value: remaining,
          color: remainingColor
        }];

        let startAngle = -Math.PI / 2;
        const hoverAreas = [];

        for (let i = depth; i > 0; i--) {
          let currentAngle = startAngle;
          slices.forEach(slice => {
            if (slice.value <= 0) return;
            const sliceAngle = (slice.value / chartData.total) * 2 * Math.PI;
            ctx.beginPath();
            ctx.moveTo(centerX, centerY + i);
            ctx.arc(centerX, centerY + i, radius, currentAngle, currentAngle + sliceAngle);
            ctx.closePath();
            ctx.fillStyle = darkenHexColor(slice.color, 0.25);
            ctx.fill();
            currentAngle += sliceAngle;
          });
        }

        let currentAngle = startAngle;
        slices.forEach(slice => {
          if (slice.value <= 0) return;
          const sliceAngle = (slice.value / chartData.total) * 2 * Math.PI;
          ctx.beginPath();
          ctx.moveTo(centerX, centerY);
          ctx.arc(centerX, centerY, radius, currentAngle, currentAngle + sliceAngle);
          ctx.closePath();
          ctx.fillStyle = slice.color;
          ctx.fill();

          hoverAreas.push({
            startAngle: currentAngle,
            endAngle: currentAngle + sliceAngle,
            data: slice
          });
          currentAngle += sliceAngle;
        });

        ctx.beginPath();
        ctx.arc(centerX, centerY, innerRadius, 0, 2 * Math.PI, false);
        ctx.fillStyle = panelColor;
        ctx.fill();

        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = textColor;
        if (chartData.total === 0) {
          ctx.font = '16px system-ui';
          ctx.fillText('No Data', centerX, centerY);
        } else {
          ctx.font = 'bold 32px system-ui';
          ctx.fillText(`${percentage}%`, centerX, centerY - 10);
          ctx.font = '14px system-ui';
          ctx.fillText(title, centerX, centerY + 20);
        }

        canvas.onmousemove = (e) => {
          const mouseRect = canvas.getBoundingClientRect();
          const x = e.clientX - mouseRect.left;
          const y = e.clientY - mouseRect.top;
          const dx = x - centerX;
          const dy = y - centerY;
          const distance = Math.sqrt(dx * dx + dy * dy);
          let angle = Math.atan2(dy, dx);
          if (angle < -Math.PI / 2) {
            angle += 2 * Math.PI;
          }
          let foundSlice = null;
          if (distance > innerRadius && distance < radius) {
            for (const area of hoverAreas) {
              if (angle >= area.startAngle && angle <= area.endAngle) {
                foundSlice = area.data;
                break;
              }
            }
          }
          if (foundSlice) {
            chartTooltip.style.display = 'block';
            chartTooltip.style.left = `${e.clientX + 15}px`;
            chartTooltip.style.top = `${e.clientY}px`;
            chartTooltip.innerHTML = `<strong>${foundSlice.label}</strong>: ${foundSlice.value}`;
            canvas.style.cursor = 'pointer';
          } else {
            chartTooltip.style.display = 'none';
            canvas.style.cursor = 'default';
          }
        };
        canvas.onmouseout = () => {
          chartTooltip.style.display = 'none';
          canvas.style.cursor = 'default';
        };
      }

      function setupBarChartInteractions(canvas) {
        canvas.onmousemove = (e) => {
          const rect = canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          let found = null;
          for (const bar of barChartHoverData.rects) {
            if (x >= bar.x && x <= bar.x + bar.w && y >= bar.y && y <= bar.y + bar.h) {
              found = bar;
              break;
            }
          }
          if (found) {
            chartTooltip.style.display = 'block';
            chartTooltip.style.left = `${e.clientX + 15}px`;
            chartTooltip.style.top = `${e.clientY}px`;
            chartTooltip.innerHTML = `<strong>${found.label}</strong>\nCompleted: ${found.completed}\nRemaining: ${found.total - found.completed}\nTotal: ${found.total}`;
          } else {
            chartTooltip.style.display = 'none';
          }
        };
        canvas.onmouseout = () => {
          chartTooltip.style.display = 'none';
        };
      }

      function drawStackedBarChart(canvas, labels, data) {
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);
        canvas.onmousemove = null;
        canvas.onmouseout = null;
        const w = rect.width;
        const h = rect.height;
        ctx.clearRect(0, 0, w, h);
        const PADDING = {
          top: 20,
          bottom: 40,
          left: 40,
          right: 20
        };
        const chartWidth = w - PADDING.left - PADDING.right;
        const chartHeight = h - PADDING.top - PADDING.bottom;
        const maxVal = Math.max(1, ...data.map(d => d.total));
        const barGroupWidth = chartWidth / labels.length;
        const barWidth = Math.min(barGroupWidth * 0.7, 50);
        const textColor = getComputedStyle(document.documentElement).getPropertyValue('--text').trim();
        const remainingColor = getComputedStyle(document.documentElement).getPropertyValue('--danger').trim();
        const completedColor = getComputedStyle(document.documentElement).getPropertyValue('--ok').trim();
        const panelColor = getComputedStyle(document.documentElement).getPropertyValue('--panel').trim();

        ctx.strokeStyle = 'rgba(255,255,255,0.18)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(PADDING.left, PADDING.top);
        ctx.lineTo(PADDING.left, PADDING.top + chartHeight);
        ctx.lineTo(PADDING.left + chartWidth, PADDING.top + chartHeight);
        ctx.stroke();

        const newRects = [];
        labels.forEach((label, i) => {
          const item = data[i];
          const totalHeight = (item.total / maxVal) * chartHeight;
          const x = PADDING.left + (i * barGroupWidth) + (barGroupWidth - barWidth) / 2;
          const y = PADDING.top + chartHeight;
          const yStart = y - totalHeight;
          if (item.total > 0) {
            const gradient = ctx.createLinearGradient(x, yStart, x, y);
            const completionRatio = item.completed / item.total;
            const stopPosition = 1 - completionRatio;
            gradient.addColorStop(0, remainingColor);
            if (stopPosition > 0.01 && stopPosition < 0.99) {
              gradient.addColorStop(stopPosition - 0.01, remainingColor);
              gradient.addColorStop(stopPosition + 0.01, completedColor);
            } else {
              gradient.addColorStop(stopPosition, remainingColor);
              gradient.addColorStop(stopPosition, completedColor);
            }
            gradient.addColorStop(1, completedColor);
            ctx.fillStyle = gradient;
            ctx.fillRect(x, yStart, barWidth, totalHeight);
          } else {
            ctx.fillStyle = panelColor;
            ctx.fillRect(x, y - 2, barWidth, 2);
          }
          newRects.push({
            x: x,
            y: yStart,
            w: barWidth,
            h: totalHeight,
            label,
            ...item
          });
          ctx.fillStyle = textColor;
          ctx.textAlign = 'center';
          ctx.save();
          ctx.translate(x + barWidth / 2, y + 10);
          ctx.rotate(labels.length > 10 ? Math.PI / 4 : 0);
          ctx.fillText(label.length > 10 ? label.slice(0, 8) + '...' : label, 0, 0);
          ctx.restore();
        });
        barChartHoverData = {
          rects: newRects,
          canvas
        };
      }

      function drawCharts() {
        const canvas = $('#mainChart');
        if (!canvas) return; // Exit if canvas not visible/ready
        const activeTab = $('#analyticsCard .tabs .tab.active')?.dataset.tab;
        const subjectSelect = $('#analyticsSubjectSelect');
        if (!activeTab || !subjectSelect) return;

        subjectSelect.style.display = 'none';
        canvas.style.cursor = 'default';
        if (activeTab === 'syllabus') {
          subjectSelect.style.display = 'block';
          const subjectId = subjectSelect.value;
          const subject = currentSyllabusPage().subjects.find(s => s.id === subjectId);
          let chartData = {
            completed: 0,
            total: 0
          };
          let title = "No Subject Selected";
          if (subject) {
            title = subject.name;
            chartData.total = subject.topics.length;
            chartData.completed = subject.topics.filter(t => t.completionDate).length;
          }
          draw3dDonutChart(canvas, chartData, title);
        } else if (activeTab === 'todo') {
          let completed = currentWS().done.length;
          let total = completed + currentWS().tasks.length;
          draw3dDonutChart(canvas, {
            completed,
            total
          }, "To-Do Progress");
        } else if (activeTab === 'timetable') {
          const labels = DAYS;
          const data = DAYS.map((day, dayIndex) => {
            let total = 0,
              completed = 0;
            Object.keys(currentWS().timetable.cells).forEach(key => {
              if (key.endsWith(`:${dayIndex}`)) {
                total++;
                if (currentWS().timetable.cells[key].completed) {
                  completed++;
                }
              }
            });
            return {
              total,
              completed
            };
          });
          drawStackedBarChart(canvas, labels, data);
          setupBarChartInteractions(canvas);
        }
      }

      function populateAnalyticsSubjectSelect() {
        const sel = $('#analyticsSubjectSelect');
        sel.innerHTML = '';
        if (currentSyllabusPage().subjects.length === 0) {
          sel.innerHTML = '<option>No subjects yet</option>';
        }
        currentSyllabusPage().subjects.forEach(s => {
          const opt = document.createElement('option');
          opt.value = s.id;
          opt.textContent = s.name;
          sel.appendChild(opt);
        });
      }
      $('#analyticsSubjectSelect').addEventListener('change', drawCharts);
      $$('#analyticsCard .tabs .tab').forEach(tab => {
        tab.addEventListener('click', () => {
          $$('#analyticsCard .tabs .tab').forEach(t => t.classList.remove('active'));
          tab.classList.add('active');
          drawCharts();
        });
      });

      /* ===== WEEKLY TIMETABLE (MODIFIED) ===== */
      const DAYS = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
      const timetableTooltip = $('#timetableTooltip');
      let timetableTooltipTimeout = null;
      let timetableTooltipHideTimeout = null;

      function handleTimetableInput(textarea, saveCallback) {
        let lastEnterPress = 0;
        textarea.addEventListener('keydown', (event) => {
          if (event.key === 'Enter' && !event.shiftKey) {
            const now = Date.now();
            if (now - lastEnterPress < 300) {
              event.preventDefault();
              const value = textarea.value;
              const cursorPos = textarea.selectionStart;
              if (cursorPos > 0 && value[cursorPos - 1] === '\n') {
                textarea.value = value.substring(0, cursorPos - 1) + value.substring(cursorPos);
                textarea.selectionStart = textarea.selectionEnd = cursorPos - 1;
              }
              saveCallback();
              lastEnterPress = 0;
            } else {
              lastEnterPress = now;
            }
          } else {
            lastEnterPress = 0;
          }
        });
      }

      function checkAndResetTimetable() {
        const ws = currentWS();
        const today = new Date();
        const currentWeekStart = getWeekStartDate(today);
        if (ws.timetable.weekStartDate !== currentWeekStart) {
          Object.values(ws.timetable.cells).forEach(cell => {
            cell.completed = false;
          });
          ws.timetable.weekStartDate = currentWeekStart;
          saveState();
        }
      }

      // MODIFIED: This function's checkbox listener now calls updateStreak()
      function renderTimetable() {
        const ws = currentWS();
        const tbl = $('#timetable');
        tbl.innerHTML = '';
        const thead = document.createElement('thead');
        const hr = document.createElement('tr');
        hr.innerHTML = '<th></th>' + DAYS.map(d => `<th>${d}</th>`).join('');
        thead.appendChild(hr);
        tbl.appendChild(thead);
        const tb = document.createElement('tbody');
        ws.timetable.rows.forEach((r, ri) => {
          const tr = document.createElement('tr');
          tr.innerHTML = `<th>${escapeHtml(r)}</th>` + DAYS.map((d, di) => {
            const key = `${ri}:${di}`;
            const cell = ws.timetable.cells[key];
            const text = cell?.text || '';
            const color = cell?.color || '';
            const isCompleted = cell?.completed || false;
            return `<td data-key="${key}"><div class="cell" style="position:relative"><input type="checkbox" title="Mark as done" ${isCompleted ? 'checked' : ''} style="margin-right: 4px;" ${!text ? 'disabled' : ''}><span class="activity-pill" style="${color ? `background:${color};color:#fff;` : 'background:rgba(255,255,255,.03)'}">${escapeHtml(text)}</span></div></td>`;
          }).join('');
          tb.appendChild(tr);
        });
        tbl.appendChild(tb);

        tbl.querySelectorAll('td[data-key]').forEach(td => {
          if (ws.timetable.cells[td.dataset.key]?.text) {
            td.addEventListener('mouseenter', (e) => {
              clearTimeout(timetableTooltipTimeout);
              clearTimeout(timetableTooltipHideTimeout);
              const key = e.currentTarget.dataset.key;
              const fullText = ws.timetable.cells[key]?.text || '';
              timetableTooltipTimeout = setTimeout(() => {
                timetableTooltip.innerHTML = `<div class="tooltip-content">${escapeHtml(fullText)}</div>`;
                timetableTooltip.style.display = 'block';
                const mx = window.innerWidth - 12 - timetableTooltip.offsetWidth;
                const my = window.innerHeight - 12 - timetableTooltip.offsetHeight;
                timetableTooltip.style.left = Math.min(e.clientX + 15, mx) + 'px';
                timetableTooltip.style.top = Math.min(e.clientY, my) + 'px';
              }, 200);
            });

            td.addEventListener('mouseleave', () => {
              clearTimeout(timetableTooltipTimeout);
              timetableTooltipHideTimeout = setTimeout(() => {
                timetableTooltip.style.display = 'none';
              }, 200);
            });
          }

          // MODIFIED: Checkbox listener
          td.querySelector('input[type="checkbox"]').onchange = (e) => {
            const key = e.target.closest('td').dataset.key;
            const isChecked = e.target.checked;
            if (ws.timetable.cells[key]) {
              ws.timetable.cells[key].completed = isChecked;
              
              if (isChecked) {
                  updateStreak(); // <-- ADDED
                  // We could add stats for timetable completions too
                  // const dateKey = new Date().toISOString().slice(0, 10);
                  // if (!ws.stats[dateKey].timetable) ws.stats[dateKey].timetable = 0;
                  // ws.stats[dateKey].timetable++;
              }

              saveState();
              
              if ($('#analyticsCard .tabs .tab[data-tab="timetable"]').classList.contains('active')) {
                drawCharts();
              }

              // Add rendering for streak and check for badges
              if(isChecked) {
                  renderStreakCounter();
                  renderStreakInfo();
                  checkAndUnlockBadges();
              }
            }
          };

          td.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            e.stopPropagation();
            const key = td.dataset.key;
            showContextMenu(e.clientX, e.clientY, [{
              label: 'Edit',
              action: () => {
                const cell = ws.timetable.cells[key] || {};
                const lastColor = ws.timetable.lastUsedColor;
                openModal(html `
                      <h3>Edit activity</h3>
                      <div class="column">
                          <textarea id="modalText" rows="1" placeholder="Activity..." style="width: 100%; overflow-y: hidden; white-space: pre; overflow-x: auto; resize: vertical; margin-bottom: 8px;">${escapeHtml(cell.text || '')}</textarea>
                          <div class="row">
                              <input id="modalColor" type="color" value="${cell.color || lastColor}" style="width:44px;height:36px;padding:2px; flex-shrink: 0;">
                              <button id="saveModal" class="accent" style="flex-grow: 1;">Save</button>
                              <button id="delModal" class="ghost">Delete</button>
                          </div>
                          <small style="color:var(--muted); margin-top: 4px;">Press Enter for a new line, double-press Enter to save.</small>
                      </div>`);

                const modalInput = $('#modalText');
                modalInput.addEventListener('input', () => autoResizeTextarea(modalInput));
                setTimeout(() => {
                  autoResizeTextarea(modalInput);
                  modalInput.focus();
                  modalInput.selectionStart = modalInput.selectionEnd = modalInput.value.length;
                }, 0);

                const saveFn = () => $('#saveModal').click();
                handleTimetableInput(modalInput, saveFn);

                $('#saveModal').onclick = () => {
                  const txt = $('#modalText').value;
                  const col = $('#modalColor').value;
                  if (txt) {
                    ws.timetable.cells[key] = {
                      text: txt,
                      color: col,
                      completed: cell.completed || false
                    };
                    ws.timetable.lastUsedColor = col;
                  } else {
                    delete ws.timetable.cells[key];
                  }
                  saveState();
                  renderTimetable();
                  closeModal();
                };
                $('#delModal').onclick = () => {
                  delete ws.timetable.cells[key];
                  saveState();
                  renderTimetable();
                  closeModal();
                };
              }
            }, {
              label: 'Delete',
              action: () => {
                delete ws.timetable.cells[key];
                saveState();
                renderTimetable();
              }
            }]);
          });
        });
      }

      function formatTimeInput(e) {
        let input = e.target;
        let value = input.value;
        if (/^\d{1,2}$/.test(value)) {
          if (value.length === 2 && parseInt(value) <= 23) {
            input.value = value + ':';
          }
        }
        if (/^\d{1,2}:\d{2}$/.test(value)) {
          input.value = value + ' - ';
        }
        if (/^\d{1,2}:\d{2} - \d{1,2}$/.test(value)) {
          const parts = value.split(' - ');
          if (parts[1].length === 2 && parseInt(parts[1]) <= 23) {
            input.value = value + ':';
          }
        }
      }

      $('#manageRows').onclick = () => {
        const ws = currentWS();
        openModal(html `<h3>Manage Rows</h3><div id="rowsWrap" style="max-height: 50vh; overflow-y: auto;"></div><div class="row" style="margin-top:10px"><input type="text" id="newRow" placeholder="e.g., 09:00 - 10:30"><button id="addRow" class="accent">Add Row</button></div>`);
        const newRowInput = $('#newRow');
        newRowInput.addEventListener('input', formatTimeInput);

        const rowsWrap = $('#rowsWrap');

        function paint() {
          rowsWrap.innerHTML = '';
          ws.timetable.rows.forEach((r, i) => {
            const row = document.createElement('div');
            row.className = 'item';
            row.innerHTML = `<span class="badge">#${i + 1}</span><div class="text">${escapeHtml(r)}</div><button class="icon-btn">‚úé</button><button class="icon-btn">üóë</button>`;
            row.querySelectorAll('button')[0].onclick = () => {
              const nv = prompt('Rename', r);
              if (nv === null) return;
              ws.timetable.rows[i] = nv.trim();
              saveState();
              paint();
            };
            row.querySelectorAll('button')[1].onclick = () => {
              ws.timetable.rows.splice(i, 1);
              Object.keys(ws.timetable.cells).forEach(k => {
                if (k.startsWith(i + ':')) delete ws.timetable.cells[k];
              });
              saveState();
              paint();
            };
            rowsWrap.appendChild(row);
          });
        }
        paint();
        $('#addRow').onclick = () => {
          const v = newRowInput.value.trim();
          if (!v) return;
          ws.timetable.rows.push(v);
          newRowInput.value = '';
          saveState();
          paint();
        };
      };

      $('#resetTimetable').onclick = () => {
        if (confirm('Are you sure you want to delete all activities for this week?')) {
          currentWS().timetable.cells = {};
          saveState();
          renderTimetable();
        }
      };

      $('#uncheckTimetable').onclick = () => {
        const ws = currentWS();
        Object.keys(ws.timetable.cells).forEach(key => {
          if (ws.timetable.cells[key]) {
            ws.timetable.cells[key].completed = false;
          }
        });
        saveState();
        renderTimetable();

        if ($('#analyticsCard .tabs .tab[data-tab="timetable"]').classList.contains('active')) {
          drawCharts();
        }
      };

      $('#addBlock').onclick = () => {
        const ws = currentWS();
        const lastColor = ws.timetable.lastUsedColor;
        openModal(html `
            <h3>Add Activity</h3>
            <div class="column">
                <div class="row">
                    <label>Row <select id="rowIdx" style="flex-grow:1;">${ws.timetable.rows.map((r, i) => `<option value="${i}">${escapeHtml(r)}</option>`).join('')}</select></label>
                    <label>Day <select id="dayIdx" style="flex-grow:1;">${DAYS.map((d, i) => `<option value="${i}">${d}</option>`).join('')}</select></label>
                </div>
                <textarea id="blockText" placeholder="Activity name..." rows="1" style="width: 100%; overflow-y: hidden; white-space: pre; overflow-x: auto; resize: vertical;"></textarea>
                <div class="row">
                    <input id="blockColor" type="color" value="${lastColor}" style="width:44px;height:36px;padding:2px; flex-shrink:0;">
                    <button id="saveBlock" class="accent" style="flex-grow: 1;">Save</button>
                    <button id="delBlock" class="ghost">Delete</button>
                </div>
                <small style="color:var(--muted); margin-top: 4px;">Press Enter for a new line, double-press Enter to save.</small>
            </div>`);

        const blockTextarea = $('#blockText');
        blockTextarea.addEventListener('input', () => autoResizeTextarea(blockTextarea));
        setTimeout(() => {
          autoResizeTextarea(blockTextarea);
          blockTextarea.focus();
        }, 0);

        const saveFn = () => {
          $('#saveBlock').click();
        };
        handleTimetableInput(blockTextarea, saveFn);

        $('#saveBlock').onclick = () => {
          const k = `${$('#rowIdx').value}:${$('#dayIdx').value}`;
          const existing = currentWS().timetable.cells[k];
          const col = $('#blockColor').value;
          currentWS().timetable.cells[k] = {
            text: $('#blockText').value,
            color: col,
            completed: existing?.completed || false
          };
          currentWS().timetable.lastUsedColor = col;
          saveState();
          renderTimetable();
          closeModal();
        };
        $('#delBlock').onclick = () => {
          const k = `${$('#rowIdx').value}:${$('#dayIdx').value}`;
          delete currentWS().timetable.cells[k];
          saveState();
          renderTimetable();
          closeModal();
        };
      };

      /* ===== STICKY NOTES (Unchanged) ===== */
      const stickyCanvas = $('#stickyNotesCanvas');
      let activeNote = null;
      let offsetX, offsetY;
      let scrollInterval = null;

      function renderStickyNotes() {
        stickyCanvas.innerHTML = '';
        currentWS().stickyNotes.forEach(note => {
          const el = document.createElement('div');
          el.className = 'sticky-note';
          el.dataset.id = note.id;
          el.style.left = `${note.x}px`;
          el.style.top = `${note.y}px`;
          el.style.background = note.color || 'var(--warn)';

          const fileHtml = (note.files || []).map(file => {
            return `<a class="file-link" href="${escapeHtml(file.url)}" target="_blank" title="${escapeHtml(file.url)}">üìÑ ${escapeHtml(file.name)}</a>`;
          }).join('');

          el.innerHTML = `
                <button class="delete-sticky-note" title="Delete Note">√ó</button>
                <textarea class="sticky-note-text" spellcheck="false">${escapeHtml(note.text)}</textarea>
                <div class="sticky-note-files">
                    ${fileHtml}
                </div>
            `;

          el.querySelector('.delete-sticky-note').onclick = (e) => {
            e.stopPropagation();
            const ws = currentWS();
            ws.stickyNotes = ws.stickyNotes.filter(n => n.id !== note.id);
            saveState();
            renderStickyNotes();
          };

          const textarea = el.querySelector('.sticky-note-text');
          textarea.addEventListener('input', debounce(() => {
            const noteToUpdate = currentWS().stickyNotes.find(n => n.id === note.id);
            if (noteToUpdate && noteToUpdate.text !== textarea.value) {
              noteToUpdate.text = textarea.value;
              saveState();
            }
          }, 500));
          textarea.addEventListener('mousedown', e => e.stopPropagation());

          el.addEventListener('mousedown', startDrag);
          el.addEventListener('dblclick', (e) => {
            if (e.target.tagName !== 'TEXTAREA' && !e.target.classList.contains('file-link')) {
              editStickyNoteFiles(note.id)
            }
          });

          stickyCanvas.appendChild(el);
        });
      }

      function startDrag(e) {
        if (e.target.tagName === 'TEXTAREA' || e.target.classList.contains('delete-sticky-note') || e.target.classList.contains('file-link')) return;
        activeNote = e.currentTarget;
        activeNote.classList.add('dragging');

        const rect = activeNote.getBoundingClientRect();

        offsetX = e.clientX - rect.left;
        offsetY = e.clientY - rect.top;

        document.addEventListener('mousemove', drag);
        document.addEventListener('mouseup', endDrag);
      }

      function drag(e) {
        if (!activeNote) return;
        e.preventDefault();

        const canvasContainer = stickyCanvas.parentElement;
        const canvasContainerRect = canvasContainer.getBoundingClientRect();

        let newX = e.clientX - canvasContainerRect.left + canvasContainer.scrollLeft - offsetX;
        let newY = e.clientY - canvasContainerRect.top + canvasContainer.scrollTop - offsetY;

        const noteStyle = window.getComputedStyle(activeNote);
        const noteWidth = parseFloat(noteStyle.width);
        const canvasWidth = 3000;

        newX = Math.max(10, Math.min(newX, canvasWidth - noteWidth - 10));
        newY = Math.max(10, newY);

        activeNote.style.left = `${newX}px`;
        activeNote.style.top = `${newY}px`;

        const scrollSpeed = 15;
        const edgeSize = 60;

        clearInterval(scrollInterval);
        scrollInterval = null;

        let scrollX = 0;
        let scrollY = 0;

        if (e.clientY < canvasContainerRect.top + edgeSize) scrollY = -scrollSpeed;
        else if (e.clientY > canvasContainerRect.top + canvasContainerRect.height - edgeSize) scrollY = scrollSpeed;

        if (e.clientX < canvasContainerRect.left + edgeSize) scrollX = -scrollSpeed;
        else if (e.clientX > canvasContainerRect.left + canvasContainerRect.width - edgeSize) scrollX = scrollSpeed;

        if (scrollX !== 0 || scrollY !== 0) {
          scrollInterval = setInterval(() => {
            canvasContainer.scrollBy(scrollX, scrollY);
            let currentX = parseInt(activeNote.style.left, 10);
            let currentY = parseInt(activeNote.style.top, 10);
            let nextX = currentX + scrollX;
            let nextY = currentY + scrollY;

            nextX = Math.max(10, Math.min(nextX, canvasWidth - noteWidth - 10));
            nextY = Math.max(10, nextY);

            activeNote.style.left = `${nextX}px`;
            activeNote.style.top = `${nextY}px`;
          }, 16);
        }
      }

      function endDrag() {
        if (!activeNote) return;

        clearInterval(scrollInterval);
        scrollInterval = null;

        const id = activeNote.dataset.id;
        const note = currentWS().stickyNotes.find(n => n.id === id);

        if (note) {
          note.x = parseInt(activeNote.style.left, 10);
          note.y = parseInt(activeNote.style.top, 10);
          saveState();
        }

        activeNote.classList.remove('dragging');
        activeNote = null;

        document.removeEventListener('mousemove', drag);
        document.removeEventListener('mouseup', endDrag);
      }

      function addStickyNote() {
        const canvasContainer = stickyCanvas.parentElement;
        const newNote = {
          id: uid(),
          x: 20 + canvasContainer.scrollLeft,
          y: 20 + canvasContainer.scrollTop,
          text: 'New Note',
          files: [],
          color: defaultAccentChoices[Math.floor(Math.random() * defaultAccentChoices.length)]
        };
        currentWS().stickyNotes.push(newNote);
        saveState();
        renderStickyNotes();
      }
      $('#addStickyNoteBtn').onclick = addStickyNote;

      function editStickyNoteFiles(id) {
        const note = currentWS().stickyNotes.find(n => n.id === id);
        if (!note) return;
        if (!note.files) note.files = [];

        openModal(html `
            <h3>Manage Links</h3>
            <h4>Attached Links:</h4>
            <div id="stickyEditFiles" class="list" style="margin-bottom:10px; max-height: 200px; overflow-y:auto;"></div>
            <div class="row" style="justify-content:space-between;">
                 <button id="addWebLinkBtn" class="ghost">Add Web URL</button>
                 <button id="closeStickyModal" class="accent">Close</button>
            </div>
        `);

        const filesContainer = $('#stickyEditFiles');

        function renderLinks() {
          filesContainer.innerHTML = (note.files || []).map((file, index) => {
            return `
                <div class="item">
                    <span class="badge">üîó</span>
                    <div class="text" title="${escapeHtml(file.url)}">${escapeHtml(file.name)}</div>
                    <button class="icon-btn" data-index="${index}" title="Remove link">üóë</button>
                </div>
            `
          }).join('');

          filesContainer.querySelectorAll('button').forEach(btn => {
            btn.onclick = () => {
              note.files.splice(Number(btn.dataset.index), 1);
              saveState();
              renderLinks();
              renderStickyNotes();
            };
          });
        }
        renderLinks();

        $('#addWebLinkBtn').onclick = () => {
          const name = prompt("Enter a name for the link:");
          if (!name || !name.trim()) return;
          const url = prompt("Enter the full web URL:", "https://");
          if (url && url.trim()) {
            note.files.push({
              name: name.trim(),
              url: url.trim(),
              type: 'url'
            });
            saveState();
            renderLinks();
            renderStickyNotes();
          }
        };

        $('#closeStickyModal').onclick = () => {
          closeModal();
        };
      }

      /* ===== CALENDAR & HISTORY (MODIFIED) ===== */
      const dateTooltip = $('#dateTooltip');
      let tooltipTimeout = null;
      let tooltipHideTimeout = null;

      function renderCalendar() {
        const grid = $('#calendarGrid');
        const monthYearEl = $('#calendarMonthYear');
        grid.innerHTML = '';

        const year = calendarCurrentDate.getFullYear();
        const month = calendarCurrentDate.getMonth();

        monthYearEl.textContent = `${calendarCurrentDate.toLocaleString('default', { month: 'long' })} ${year}`;

        const firstDayOfMonth = new Date(year, month, 1).getDay();
        const daysInMonth = new Date(year, month + 1, 0).getDate();

        const dayOffset = firstDayOfMonth === 0 ? 6 : firstDayOfMonth - 1;

        'Mon,Tue,Wed,Thu,Fri,Sat,Sun'.split(',').forEach(day => {
          const dayEl = document.createElement('div');
          dayEl.className = 'calendar-day';
          dayEl.textContent = day;
          grid.appendChild(dayEl);
        });

        for (let i = 0; i < dayOffset; i++) {
          const emptyCell = document.createElement('div');
          grid.appendChild(emptyCell);
        }

        const today = new Date().toISOString().slice(0, 10);

        for (let day = 1; day <= daysInMonth; day++) {
          const dateCell = document.createElement('div');
          dateCell.className = 'date-cell';
          dateCell.textContent = day;
          const dateString = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
          dateCell.dataset.date = dateString;

          if (dateString === today) {
            dateCell.classList.add('today');
          }

          // NEW: Check for reminder first, then data
          if (hasReminderForDate(dateString)) {
            dateCell.classList.add('has-reminder');
          } else if (hasDataForDate(dateString)) {
            dateCell.classList.add('has-data');
          }

          dateCell.addEventListener('mouseenter', (e) => {
            clearTimeout(tooltipTimeout);
            clearTimeout(tooltipHideTimeout);
            tooltipTimeout = setTimeout(() => {
              showDateTooltip(dateString, e.clientX, e.clientY);
            }, 150);
          });
          dateCell.addEventListener('mouseleave', () => {
            clearTimeout(tooltipTimeout);
            tooltipHideTimeout = setTimeout(() => {
              dateTooltip.style.display = 'none';
            }, 200);
          });

          // NEW: Add dblclick listener for reminders
          dateCell.addEventListener('dblclick', () => {
            openReminderModal(dateString);
          });

          grid.appendChild(dateCell);
        }
      }

      function hasDataForDate(dateString) {
        const ws = currentWS();
        const doneTasks = ws.done.filter(t => new Date(t.when).toISOString().slice(0, 10) === dateString).length > 0;
        if (doneTasks) return true;

        const completedTopics = ws.syllabusPages.some(page =>
          page.subjects.some(s =>
            s.topics.some(t => t.completionDate === dateString)
          )
        );
        if (completedTopics) return true;

        return false;
      }

      function showDateTooltip(dateString, x, y) {
        const ws = currentWS();
        let content = `<div class="tooltip-content"><strong>${dateString}</strong>`;
        let foundData = false;

        // NEW: Check reminders
        const reminders = getReminders(dateString);
        if (reminders.length > 0) {
          foundData = true;
          content += '<h4>Reminders</h4>';
          reminders.forEach(r => content += `<p style="color: var(--warn); margin-left: 8px;">‚òÖ ${escapeHtml(r.text)}</p>`);
        }

        const doneTasks = ws.done.filter(t => new Date(t.when).toISOString().slice(0, 10) === dateString);
        if (doneTasks.length > 0) {
          foundData = true;
          content += '<h4>To-Do Completed</h4>';
          doneTasks.forEach(t => content += `<p>- ${escapeHtml(t.text)}</p>`);
        }

        let completedTopics = [];
        ws.syllabusPages.forEach(page =>
          page.subjects.forEach(s =>
            s.topics.forEach(t => {
              if (t.completionDate === dateString) {
                completedTopics.push(`[${s.name}] ${t.name}`);
              }
            })
          )
        );
        if (completedTopics.length > 0) {
          foundData = true;
          content += '<h4>Syllabus Topics</h4>';
          completedTopics.forEach(t => content += `<p>- ${escapeHtml(t)}</p>`);
        }

        if (!foundData) {
          content += '<p style="color: var(--muted); margin-top: 8px;">No activity recorded.</p>';
        }

        content += '</div>';
        dateTooltip.innerHTML = content;
        dateTooltip.style.display = 'block';
        const mx = window.innerWidth - 12 - dateTooltip.offsetWidth;
        const my = window.innerHeight - 12 - dateTooltip.offsetHeight;
        dateTooltip.style.left = Math.min(x + 15, mx) + 'px';
        dateTooltip.style.top = Math.min(y, my) + 'px';
      }

      function navigateCalendar(dir) {
        const grid = $('#calendarGrid');
        grid.classList.remove('flip-next', 'flip-prev');
        void grid.offsetWidth;

        calendarCurrentDate.setMonth(calendarCurrentDate.getMonth() + dir);

        if (dir > 0) {
          grid.classList.add('flip-next');
        } else {
          grid.classList.add('flip-prev');
        }

        setTimeout(() => {
          renderCalendar();
          grid.classList.remove('flip-next', 'flip-prev');
        }, 300);
      }
      $('#calendarPrev').onclick = () => navigateCalendar(-1);
      $('#calendarNext').onclick = () => navigateCalendar(1);


      /* ===== MODAL & TEMPLATE LITERAL (Unchanged) ===== */
      function html(strings, ...vals) {
        return strings.map((s, i) => s + (vals[i] ?? '')).join('');
      }

      function openModal(content) {
        $('#modalCard').innerHTML = content;
        $('#modal').style.display = 'flex';
      }

      function closeModal() {
        $('#modal').style.display = 'none';
        $('#modalCard').innerHTML = '';
      }
      $('#modal').addEventListener('click', e => {
        if (e.target.id === 'modal') closeModal();
      });

      /* ===== RESET FUNCTIONALITY (FIXED) ===== */
      $('#openResetSettings').onclick = openResetModal;

      function openResetModal() {
        openModal(html `
            <h3>Reset or Clear Data</h3>
            <p style="color:var(--muted); font-size: 12px;">Be careful, these actions cannot be undone.</p>
            <div class="column" style="gap: 12px; margin-top: 16px;">
              <button id="resetCurrent" class="ghost" style="border-color: var(--warn); color: var(--warn);">Reset <strong>${escapeHtml(currentWS().name)}</strong> Workspace</button>
              <button id="resetAll" class="ghost" style="border-color: var(--danger); color: var(--danger);">Factory Reset (Delete All Data)</button>
            </div>
          `);

        $('#resetCurrent').onclick = () => {
          confirmAndReset('current');
        };

        $('#resetAll').onclick = () => {
          confirmAndReset('all');
        };
      }

      function confirmAndReset(type) {
        const messages = {
          current: `Are you sure you want to reset the "${escapeHtml(currentWS().name)}" workspace?\nAll its data (tasks, syllabus, etc.) will be lost.`,
          all: 'WARNING: This will delete ALL data in every workspace and reset the entire app. This action cannot be undone. Are you sure?'
        };

        openModal(html `
            <h3>Confirmation</h3>
            <p style="white-space: pre-wrap;">${messages[type]}</p>
            <div class="row" style="justify-content: flex-end;">
                <button id="confirmCancel" class="ghost">Cancel</button>
                <button id="confirmYes" class="accent" style="background: var(--danger);">Yes, Reset</button>
            </div>
        `);

        $('#confirmCancel').onclick = () => openResetModal(); // Go back to reset modal
        $('#confirmYes').onclick = () => {
          resetLogic(type);
          closeModal();
        };
      }

      function resetLogic(type) {
        const d = DEFAULT();
        if (type === 'all') {
          localStorage.removeItem(STATE_KEY);
          state = loadState();
          renderAll();
          return;
        }
        if (type === 'current') {
          state.workspaces[state.current] = { ...DEFAULT().workspaces[0],
            name: currentWS().name
          };
        }
        saveState();
        renderAll();
      }


      /* ===== IMPORT/EXPORT FUNCTIONALITY (Completed) ===== */
      function exportData() {
        try {
          const dataStr = JSON.stringify(state, null, 2);
          const dataBlob = new Blob([dataStr], {
            type: 'application/json'
          });
          const url = URL.createObjectURL(dataBlob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `focus-deck_backup_${new Date().toISOString().slice(0, 10)}.json`;
          a.click();
          URL.revokeObjectURL(url);
        } catch (e) {
          console.error('Export failed:', e);
          alert('Could not export data.');
        }
      }
      $('#exportData').onclick = exportData;

      function importData() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json,application/json';
        input.onchange = e => {
          const file = e.target.files[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = readEvent => {
            try {
              const newState = JSON.parse(readEvent.target.result);
              if (newState && newState.version && newState.workspaces) {
                if (confirm('Import successful. Replace current data?')) {
                  state = newState;
                  // Ensure migration if it's an older (but valid) schema
                  if (!state.version || state.version < DEFAULT().version) {
                    state = migrate(state);
                  }
                  saveState();
                  renderAll();
                }
              } else {
                alert('Invalid file format.');
              }
            } catch (err) {
              console.error('Import failed:', err);
              alert('Could not import file. Is it a valid JSON backup?');
            }
          };
          reader.readAsText(file);
        };
        input.click();
      }
      $('#importData').onclick = importData;


      /* ===== GLOBAL SEARCH FUNCTIONALITY (Completed) ===== */
      function filterTodo(query) {
        $$('#todoList .task-item').forEach(el => {
          const text = el.querySelector('.text').textContent.toLowerCase();
          let subtextMatch = false;
          el.querySelectorAll('.subtask-list-container .text').forEach(sub => {
            if (sub.textContent.toLowerCase().includes(query)) {
              subtextMatch = true;
            }
          });
          el.style.display = (text.includes(query) || subtextMatch) ? '' : 'none';
        });
      }

      function filterSyllabus(query) {
        $$('#subjects .subj').forEach(el => {
          const title = el.querySelector('.subj-title').textContent.toLowerCase();
          let topicMatch = false;
          el.querySelectorAll('.topics .topic .text').forEach(topic => {
            if (topic.textContent.toLowerCase().includes(query)) {
              topicMatch = true;
              topic.parentElement.style.display = '';
            } else {
              topic.parentElement.style.display = 'none';
            }
          });
          // Show subject if title matches OR a topic matches
          el.style.display = (title.includes(query) || topicMatch) ? '' : 'none';
          // If a topic matched, force-expand the subject
          if (topicMatch && el.classList.contains('collapsed')) {
            el.querySelector('.topics').style.display = 'block';
          } else if (el.classList.contains('collapsed')) {
            el.querySelector('.topics').style.display = 'none';
          }
        });
      }

      $('#globalSearch').addEventListener('input', debounce(e => {
        const query = e.target.value.trim().toLowerCase();
        filterTodo(query);
        filterSyllabus(query);
      }, 200));


      /* ===== SETTINGS: TIMER DURATIONS (Completed) ===== */
      function renderDurations() {
        const dur = currentWS().timer.dur;
        $('#durFocus').value = dur.focus;
        $('#durShort').value = dur.short;
        $('#durLong').value = dur.long;
      }
      $('#saveDur').addEventListener('click', () => {
        const ws = currentWS();
        ws.timer.dur.focus = Number($('#durFocus').value);
        ws.timer.dur.short = Number($('#durShort').value);
        ws.timer.dur.long = Number($('#durLong').value);
        saveState();
        setModeUI(); // Update timer display
      });


      /* ===== APPLICATION LIFECYCLE & INIT (Completed) ===== */
      function renderAll() {
        // Daily check
        checkAndResetRecurringTasks();
        checkAndResetTimetable();

        // Apply theme
        applyTheme(); // This now also sets the header icon
        renderAccentPalette();

        // Header & Workspaces
        renderWorkspaceSelect();
        renderStreakCounter();

        // Settings
        renderDurations();

        // Left Column
        setModeUI(); // Correctly sets the timer display
        renderStreakInfo();
        renderBadges();

        // Right Column
        initRightColumnTabs(); // This now handles which card is visible
        renderTasks();
        renderSyllabusNav();
        renderSyllabus();
        populateAnalyticsSubjectSelect();
        drawCharts();
        renderTimetable();
        renderStickyNotes();
        renderCalendar();

        // Misc
        initExpandButtons(); // Re-init all expand buttons
      }

      function init() {
        renderAll();
        backupAuto();

        // Set up a daily check for recurring tasks every minute, to catch the midnight change.
        setInterval(checkAndResetRecurringTasks, 60 * 1000);
        // Also check timetable daily
        setInterval(checkAndResetTimetable, 60 * 1000);

        dateTooltip.addEventListener('mouseenter', () => {
          clearTimeout(tooltipHideTimeout);
        });
        dateTooltip.addEventListener('mouseleave', () => {
          tooltipHideTimeout = setTimeout(() => {
            dateTooltip.style.display = 'none';
          }, 200);
        });

        timetableTooltip.addEventListener('mouseenter', () => {
          clearTimeout(tooltipHideTimeout);
        });
        timetableTooltip.addEventListener('mouseleave', () => {
          timetableTooltipHideTimeout = setTimeout(() => {
            timetableTooltip.style.display = 'none';
          }, 200);
        });

        window.addEventListener('scroll', () => {
          hideContextMenu();
        });
        window.addEventListener('resize', debounce(() => {
          hideContextMenu();
          renderTimetable();
          drawCharts();
        }, 100));
        document.addEventListener('keydown', e => {
          if (e.key === 'Escape') {
            closeModal();
            hideContextMenu();
            $$('.card.expanded').forEach(c => minimizeCard(c.id));
          }
        });
      }

      // This is the main wrapper to run the app
      init();

    }); // <-- This closes the DOMContentLoaded listener
  </script>
</body>

</html>
